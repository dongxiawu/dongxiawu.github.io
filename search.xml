<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java枚举类型原理]]></title>
    <url>%2F2018%2F05%2F16%2FJava%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 枚举（Enum）类型是 java 5 中新增的一种数据类型，它能够帮助我们更加快捷和安全的实现枚举。 回想之前我们在定义枚举常量时的做法： public static final int MONDAY =1; public static final int TUESDAY=2; public static final int WEDNESDAY=3; public static final int THURSDAY=4; public static final int FRIDAY=5; public static final int SATURDAY=6; public static final int SUNDAY=7; 这样的定义方式虽然也能正常工作，但却存在许多不足，比如不小心把 MONDAY 和 TUESDAY 都置为 2 时，编译器并不会报错，但是却很难进行排查。 在 Java 5 之后，我们可以用如下的定义定义枚举类型。 public enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY; } 并可以在程序中通过 Day.MONDAY 的方式使用，这无疑大大提高了程序的安全性。 我们知道，编程语言的设计具有前向兼容性，这意味着后续的语言特性实际上都是通过语法糖来实现的，那么枚举类型的内部实现原理是怎么样的呢？我们通过将上面的枚举类 Day 通过 javap 命令进行反编译，再将反编译的代码通过改写使其更加容易阅读，最终得到下面的反编译代码。 public final class Day extends Enum&lt;Day&gt; { //编译器为我们添加的静态的values()方法 public static Day[] values() { return (Day[])$VALUES.clone(); } //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法 public static Day valueOf(String s) { return (Day)Enum.valueOf(Day, s); } //私有构造函数 private Day(String s, int i) { super(s, i); } //前面定义的7种枚举实例 public static final Day MONDAY; public static final Day TUESDAY; public static final Day WEDNESDAY; public static final Day THURSDAY; public static final Day FRIDAY; public static final Day SATURDAY; public static final Day SUNDAY; private static final Day $VALUES[]; static { //实例化枚举实例 MONDAY = new Day(&quot;MONDAY&quot;, 0); TUESDAY = new Day(&quot;TUESDAY&quot;, 1); WEDNESDAY = new Day(&quot;WEDNESDAY&quot;, 2); THURSDAY = new Day(&quot;THURSDAY&quot;, 3); FRIDAY = new Day(&quot;FRIDAY&quot;, 4); SATURDAY = new Day(&quot;SATURDAY&quot;, 5); SUNDAY = new Day(&quot;SUNDAY&quot;, 6); $VALUES = new Day[] { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }; } } 通过阅读上面的反编译后代码，我们可以对枚举类型的实现进行总结： 枚举类型是通过继承 Enum 类来实现的，并且最终生成 final 类来强化不可变性。 枚举类型的构造函数为私有的，具有 String 和 int 两个参数，分别代表枚举的名称和序号，序号按照定义的顺序从小到大排列。 每一个枚举都代表一个枚举类事例，并且为 static 和 final，在枚举类的静态代码块中进行初始化，并且有一个 $VALUES 数组保存所有的枚举。 通过 valueOf 方法可以完成枚举名称到枚举对象的查找。 values()方法返回的是 $VALUES 数组的克隆对象，这能防止$VALUES 数组被篡改。 接下来，我们来分析一下自定义枚举类型所继承的 Enum 类 public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable { private final String name; public final String name() { return name; } private final int ordinal; public final int ordinal() { return ordinal; } protected Enum(String name, int ordinal) { this.name = name; this.ordinal = ordinal; } public String toString() { return name; } public final boolean equals(Object other) { return this==other; } public final int hashCode() { return super.hashCode(); } protected final Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(); } public final int compareTo(E o) { Enum&lt;?&gt; other = (Enum&lt;?&gt;)o; Enum&lt;E&gt; self = this; if (self.getClass() != other.getClass() &amp;&amp; self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; } @SuppressWarnings(&quot;unchecked&quot;) public final Class&lt;E&gt; getDeclaringClass() { Class&lt;?&gt; clazz = getClass(); Class&lt;?&gt; zuper = clazz.getSuperclass(); return (zuper == Enum.class) ? (Class&lt;E&gt;)clazz : (Class&lt;E&gt;)zuper; } public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) { T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException(&quot;Name is null&quot;); throw new IllegalArgumentException( &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name); } protected final void finalize() { } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { throw new InvalidObjectException(&quot;can&apos;t deserialize enum&quot;); } private void readObjectNoData() throws ObjectStreamException { throw new InvalidObjectException(&quot;can&apos;t deserialize enum&quot;); } } 通过阅读上面的 Enum 抽象类，我们可以对其特点进行总结： 由 equals 方法可知每个枚举只与自身相等，没有等效相等的枚举。 由 clone 方法可知枚举对象不允许克隆，这能保证每一个枚举都是唯一的。 由 compareTo 方法可知枚举只能与同类型的枚举相比较，返回结果为枚举的顺序之差。 由 finalize 方法可知枚举类不允许实现 finalize 方法，这与枚举的安全性有关。 由 readObject 方法和 readObjectNoData 方法可知枚举对象不允许反序列化，这也能保证每一个枚举都是唯一的。 由以上的分析我们可以发现，枚举的最大特点就是唯一性，同时可以发现只有单个元素的枚举在不经意间符合了单例模式的要求，具体为： 枚举类为不可变类，这防止了单例类被继承。 枚举类型的构造函数为私有的，因此不能主动创建对应的单例对象。 枚举的元素为 public static final 类型，并且在类加载的时候在静态代码块内完成了初始化，这相当于单例模式的恶汉模式。 枚举类对象不允许克隆，这能保证每一个单例都是唯一的。 枚举类对象不可反序列化，这也能保证每一个单例都是唯一的。 因此我们可以使用单元素的枚举类型来实现单例模式。事实上，正如 Effective Java 一书中所说的：单元素的枚举类型已经成为实现 Singleton 的最佳方法。 注意 ：值得提出的时，由以上的分析我们知道每一个枚举都是一个对象，既然是对象，那么它所占的内存就比基本类型大很多，这就是枚举类型的缺点，所以在Android开发中并不建议使用枚举类型，而是使用@interface+@IntDef/@StringDef等注解加上int或者String进行替代。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Enum</tag>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化与反序列化]]></title>
    <url>%2F2018%2F05%2F15%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 前言Java 的序列化相信大家都不陌生。当我们需要讲对象存储起来或进行传输时，就需要对 Java 对象进行序列化，那么在序列化过程中有什么需要注意的呢？ Serializable基础用法当我们要序列化一个类时，可以选择实现 Serializable 接口，注意，这是一个 标记接口，也就是说这个接口并没有任何方法或者成员变量，仅仅告诉 JVM 该类可以被序列化。 例： public class Animal implements Serializable{ public int age; public Animal(int age) { this.age = age; } @Override public String toString() { return &quot;Animal [age=&quot; + age + &quot;]&quot;; } } 此时，该类就可以被存储或者传输了。 例： public class Main{ public static final void main(String[] args) { ObjectOutputStream objectOutputStream = null; try { Animal animal = new Animal(2); System.out.println(animal); objectOutputStream = new ObjectOutputStream( new FileOutputStream(new File(&quot;file1&quot;))); objectOutputStream.writeObject(animal); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if (objectOutputStream != null) { objectOutputStream.flush(); objectOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } ObjectInputStream objectInputStream = null; try { objectInputStream = new ObjectInputStream( new FileInputStream(new File(&quot;file1&quot;))); Object object = objectInputStream.readObject(); System.out.println(object); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if (objectInputStream != null) { objectInputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 输出结果： Animal [age=2] Animal [age=2] 可以看到，成功的实现了对象的保存与恢复，有的时候，我们并不希望所有成员变量都进行保存，比如有一些敏感信息等。这时候就可以将不保存的成员变量声明为 transient,如：transient public int age，这样在序列化的时候就不会保存该成员变量，相应的反序列化的时候该成员变量将不会被赋值。 自定义序列化逻辑默认情况下，JVM会自动帮我们做序列化和反序列化的工作，但有的时候我们想自己在序列化和反序列化的时候添加上自己的逻辑，如加解密等，这就涉及到了以下的方法： private void writeObject(java.io.ObjectOutputStream out) throws IOException; private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException; private void readObjectNoData() throws ObjectStreamException; 其中，writeObject()方法 用于保存对象的状态以便 readObject()方法进行恢复，可以调用out.defaultWriteObject 进行默认保存。写入的对象可以是有效的成员变量或者DataOutput中支持的基本类型 readObject()方法用于从数据流中恢复类的非静态和非瞬时成员变量，in.defaultReadObject()为默认的恢复方法。 注意 readObject()方法中的恢复顺序必须与与writeObject()方法中的保存顺序一致。 以上的两个方法均可以不关注属于父类或子类的成员变量。 readObjectNoData()方法比较特殊，其作用为当序列化流没有将给定的类认定为反序列化的对象的超类时，该方法可以用于初始化一个反序列化对象。其原理为调用反序列化对象的无参构造函数，并进行对应初始化。这就要求反序列化对象必须有无参构造函数。 这种情况在当接收方与发送方的反序列化类版本不同，并且 接收方的类继承了某些发送方没有继承的类(而没有改动类的内容);或者序列化流被篡改了，变得不完整的时候会发生。 例子： public class Main{ public static final void main(String[] args) { ObjectOutputStream objectOutputStream = null; try { Persion persion = new Persion(&quot;jack&quot;); System.out.println(persion); objectOutputStream = new ObjectOutputStream( new FileOutputStream(new File(&quot;file1&quot;))); objectOutputStream.writeObject(persion); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if (objectOutputStream != null) { objectOutputStream.flush(); objectOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } public class Persion implements Serializable { public String name; public Persion() { } public Persion (String name) { this.name = name; } @Override public String toString() { return &quot;Persion [&quot; + &quot;name=&quot; + name +&quot;]&quot;; } } 先将 Person 对象保存起来，然后修改 Person 类，使其继承 Animal 类，并在 Animal 类中实现 readObjectNoData() 方法，最后尝试恢复对象。 public class Persion extends Animal implements Serializable { public String name; public Persion() { } public Persion (String name) { this.name = name; } @Override public String toString() { return &quot;Persion [&quot; + &quot;name=&quot; + name + &quot;, age=&quot; + age +&quot;]&quot;; } } public class Animal implements Serializable{ transient public int age; public Animal() { } public Animal(int age) { this.age = age; } private void readObjectNoData() throws ObjectStreamException { this.age = 20; } @Override public String toString() { return &quot;Animal [age=&quot; + age + &quot;]&quot;; } } public class Main{ public static final void main(String[] args) { ObjectInputStream objectInputStream = null; try { objectInputStream = new ObjectInputStream( new FileInputStream(new File(&quot;file1&quot;))); Object object = objectInputStream.readObject(); System.out.println(object); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if (objectInputStream != null) { objectInputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 可以发现 Animal 类的 readObjectNoData() 方法被调用了，输出结果为：Persion [name=jack, age=20] 替换序列化对象有的时候，我们想将其他对象而不是当前对象进行序列化保存或传输，比如代理类的情况，这个时候就可以通过实现Object writeReplace() throws ObjectStreamException方法达到，该方法可以是任何访问属性，子类也遵循访问规则。 值得提出的是，反序列化的对象和原来的对象并不是同一个对象，如果这个时候对两个对象进行 == 测试，则结果为 false。有的时候，我们希望反序列化的对象和原来的对象是同一个对象，比如在单例模式的时候，这个时候可以通过实现Object readResolve() throws ObjectStreamException;方法进行反序列化对象替换。该方法可以是任何访问属性。 例： public class Animal implements Serializable{ transient public int age; public Animal() { } public Animal(int age) { this.age = age; } public Object readResolve() throws ObjectStreamException { return new Animal(3); } @Override public String toString() { return &quot;Animal [age=&quot; + age + &quot;]&quot;; } } public class Main{ public static final void main(String[] args) { ObjectOutputStream objectOutputStream = null; try { Animal animal = new Animal(2); System.out.println(animal); objectOutputStream = new ObjectOutputStream( new FileOutputStream(new File(&quot;file1&quot;))); objectOutputStream.writeObject(animal); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if (objectOutputStream != null) { objectOutputStream.flush(); objectOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } ObjectInputStream objectInputStream = null; try { objectInputStream = new ObjectInputStream( new FileInputStream(new File(&quot;file1&quot;))); Object object = objectInputStream.readObject(); System.out.println(object); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if (objectInputStream != null) { objectInputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 此时的输出结果为： Animal [age=2] Animal [age=3] serialVersionUID序列化运行时分配给每一个序列化类一个版本号，称为serialVersionUID，在反序列化过程中使用该版本号来验证序列化对象的发送者和接收者是否已加载该对象的与序列化相容的类。如果接收者为与对应的发送者类具有不同serialVersionUID的对象加载类，则反序列化将导致InvalidClassException异常。一个可序列化的类可以通过声明一个名为serialVersionUID的字段声明自己的serialVersionUID，该字段必须是static final long类型，可以是任何访问属性。 如果可序列化类没有显式声明serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认serialVersionUID值，如Java（TM）对象序列化规范中所述。然而，强烈建议所有可序列化的类显式声明serialVersionUID值，因为默认的serialVersionUID计算对类详细信息高度敏感，可能因编译器实现而异，因此可能会导致在反序列化过程中抛出InvalidClassException。因此，要确保跨不同的java编译器实现保持一致的serialVersionUID值，可序列化的类必须声明显式的serialVersionUID值。还强烈建议显式serialVersionUID声明尽可能使用 private 修饰符，因为这些声明仅适用于立即声明的类serialVersionUID字段作为继承成员是无用的。数组类无法声明显式的serialVersionUID，因此它们始终具有默认的计算值，但是对于数组类而言，不需要匹配serialVersionUID值。 Externalizable序列化的接口除了 Serializable 还有 Externalizable，二者的不同在于 Externalizable 有以下的两个方法： void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException; 通过实现 Externalizable 接口实现序列化的类除了需要控制该类成员变量的的保存与恢复，还需要控制其父类成员变量的保存与恢复。 其通过上述的两个方法实现。 例子： public class Animal implements Serializable{ transient public int age; public Animal() { } public Animal(int age) { this.age = age; } @Override public String toString() { return &quot;Animal [age=&quot; + age + &quot;]&quot;; } } public class Persion extends Animal implements Externalizable { public String name; public Persion() { } public Persion (String name, int age) { this.name = name; this.age = age; } @Override public void writeExternal(ObjectOutput out) throws IOException { out.writeObject(name); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{ name = (String )in.readObject(); } @Override public String toString() { return &quot;Persion [&quot; + &quot;name=&quot; + name + &quot;, age=&quot; + age +&quot;]&quot;; } } public class Main{ public static final void main(String[] args) { ObjectOutputStream objectOutputStream = null; try { Persion persion = new Persion(&quot;Jack&quot;, 25); System.out.println(persion); objectOutputStream = new ObjectOutputStream( new FileOutputStream(new File(&quot;file1&quot;))); objectOutputStream.writeObject(persion); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if (objectOutputStream != null) { objectOutputStream.flush(); objectOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } ObjectInputStream objectInputStream = null; try { objectInputStream = new ObjectInputStream( new FileInputStream(new File(&quot;file1&quot;))); Object object = objectInputStream.readObject(); System.out.println(object); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if (objectInputStream != null) { objectInputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 其输出结果为： Persion [name=Jack, age=25] Persion [name=Jack, age=0] 故表明通过实现 Externalizable 接口实现序列化的类除了需要控制该类成员变量的的保存与恢复，还需要控制其父类成员变量的保存与恢复。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Serializable</tag>
        <tag>Externalizable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intent与IntentFilter]]></title>
    <url>%2F2018%2F05%2F04%2FIntent%E4%B8%8EIntentFilter%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 前言Intent 这个类相信大家都不陌生。这个类的中文名称为 意图 ,主要用于 Android 四大组件之间传递信息。那么这个类有什么值得注意的地方呢？还有 Intent 和 IntentFilter 之间是如何匹配的呢？ Intent了解一个类最直接的方式就是查看源码，所以我们通过源码首先看看 Intent 这个类有哪些成员变量。 private String mAction; private Uri mData; private String mType; private String mPackage; private ComponentName mComponent; private int mFlags; private ArraySet&lt;String&gt; mCategories; private Bundle mExtras; private Rect mSourceBounds; private Intent mSelector; private ClipData mClipData; private int mContentUserHint = UserHandle.USER_CURRENT; private String mLaunchToken; 其实从 Intent 的成员变量中我们已经可以大概知道 Intent 的作用了。我们知道 Intent 有显式和隐式之分，其中，显式 Intent 主要设置的就是 ComponentName mComponent 这个成员变量，比如： Intent intent = new Intent(MainActivity.this,SecondActivity.class); startActivity(intent); 而隐式 Intent 主要设置的就是以下的几个成员变量 private String mAction; private Uri mData; private String mType; private ArraySet&lt;String&gt; mCategories; 从中我们可以得出，Action、Data、Type 都最多只有一个值，而 Category 可以有多个值。 隐式 Intent 的主要使用方式为： Intent intent = new Intent(); intent.setAction(Intent.ACTION_SEND); intent.addCategory(Intent.CATEGORY_APP_BROWSER); startActivity(intent); 注意，若需要同时设置Data和Type两个属性时，必须使用setDataAndType()方法，不要同时调用setData()和setType()方法，因为这两个方法设置的值会相互覆盖 public Intent setData(Uri data) { mData = data; mType = null; return this; } public Intent setType(String type) { mData = null; mType = type; return this; } IntentFilter当设置完 Intent 对象后，要启动的是哪个组件呢？这就由 IntentFilter 决定了。 IntentFilter 通常在 AndroidManifest.xml 中设置，如： &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 与 Intent 相同，我们先看一下 IntentFilter 的成员变量如下： private int mPriority; private int mOrder; private final ArrayList&lt;String&gt; mActions; private ArrayList&lt;String&gt; mCategories = null; private ArrayList&lt;String&gt; mDataSchemes = null; private ArrayList&lt;PatternMatcher&gt; mDataSchemeSpecificParts = null; private ArrayList&lt;AuthorityEntry&gt; mDataAuthorities = null; private ArrayList&lt;PatternMatcher&gt; mDataPaths = null; private ArrayList&lt;String&gt; mDataTypes = null; private boolean mHasPartialTypes = false; 从中我们可以看到，由于Action，Category，DataType 等都是链表，所以 IntentFilter 中，Action、Data、Type 都允许有多个值。 而且每一个组件都允许存在多个 IntentFilter。 至于 Intent 和 IntentFilter 之间的匹配规则为： 显式 Intent：直接通过类名查找，故不需要 IntentFilter。 隐式 Intent：它必须有一个IntentFilter 的属性包含CATEGORY_DEFAULT，因为startActivity()和startActivityForResult()方法处理 隐式Intent 时候，默认的认为接受组件有一个属性为CATEGORY_DEFAULT的过滤器。如果一个Activity组件不声明这样一个过滤器，它就接收不到 隐式Intent。 IntentFilter 必须包含 Intent 的 Action 属性（如果 Intent 有） IntentFilter 必须包含 Intent 的所有 Category 属性（如果 Intent 有），同时必须有一个 Category 的属性值为CATEGORY_DEFAULT。 每个Data属性都可以指定数据的URI结构和数据MIME类型。URI包括scheme、host、port 和path四个部分，host和port合起来也成authority（host:port）部分。 &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt; 例如： content://192.168.0.1:8080/folder/subfolder/etc 在这个URI中，scheme是content，host是192.168.0.1，port是8080，path是folder/subfolder/etc。我们平时使用的网络url就是这种格式。 匹配规则： 在URI中，每个组成部分都是可选的，但是有线性的依赖关系 如果没有scheme部分，那么host部分会被忽略 如果没有host部分，那么port部分会被忽略 如果host部分和port部分都没有，那么path部分会被忽略 当进行URI匹配时候，并不是比较全部，而是局部对比，以下是URI匹配规则。 如果一个URI仅声明了scheme部分，那么所有拥有与其相同的scheme的URI都会通过匹配，其他部分不做匹配 如果一个URI声明了scheme部分和authority部分，那么拥有与其相同scheme和authority的URI才能匹配成功，path部分不做匹配 如果一个URI所有的部分都声明了，那么只有所有部分都相同的URI才能匹配成功 注意：path部分可以使用通配符*，也就是path其中的一部分进行匹配。 Data匹配时候，MIME类型和URI两者都会进行匹配，匹配规则如下： 如果过滤器未声明URI和MIME类型，则只有不含URI和MIME类型的隐式Intent才能匹配成功 如果过滤器中声明URI但是未声明MIME类型（也不能从URI中分析出MIME类型），则只有URI与过滤器URI相同且不包含IME类型的隐式Intent才能匹配成功 如果过滤器声明MIME类型但是未声明URI，只有包含相同MIME类型但是不包含URI的隐式Intent才能匹配成功 如果过滤器声明了URI和MIME类型（既可以是直接设置，也可以是从URI分析出来），只有包含相同的URI和MIME类型的隐式Intent才能匹配成功]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Intent</tag>
        <tag>IntentFilter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解与注解处理器]]></title>
    <url>%2F2018%2F04%2F18%2FJava%E6%B3%A8%E8%A7%A3%E4%B8%8E%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 元注解@Retention@Retention：保留期，表示注解的存活时间，取值为： RetentionPolicy.SOURCE：注解只在源码阶段保留，编译后忽略，主要起到提示、警告的作用，如@Override RetentionPolicy.CLASS：注解保留到编译后的class文件中，运行时忽略，即不会加载到虚拟机中，但是可以通过读文件的形式获取class文件中的注解，该类注解可以在编译时进行规则检查或自动生成某些代码，如@NonNull RetentionPolicy.RUNTIME：注解保留到运行时，可以在运行时获取，可以用作动态条件判断等功能，如@Inherited、@Documented @Documented@Documented:文档，含有该注解的注解能够被javadoc生成java文档 @Target@Target：表示该注解的作用范围，取值为： ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @Inherited@Inherited：表示该注解是否可以被继承，当父类使用了可继承的注解，子类默认也含有该注解 @Native@Native：表示变量来自本地代码 @Repeatable@Repeatable：Java 1.8新增，代表注解的类可以有多个取值 自定义注解语法Java中，可以使用@interface关键字创建自定义注解： @Documented @Target(ElementType.METHOD) @Inherited @Retention(RetentionPolicy.RUNTIME) public @interface MethodInfo { String author() default &quot;&quot;; String date(); int version() default 1; String comments(); } 注意事项 使用@interface自定义注解时，自动继承了 java.lang.annotation.Annotation 接口 注解中的方法，实际是声明了一个配置参数，参数名称就是方法名，返回值类型智能是基本类型、Class、String、enum、Annotation以及前面类型的数组。可以通过default来声明参数默认值。 注解中的方法，不允许使用project、private修饰符，也无需加上public修饰符，这一点和接口类似。 自定义注解需要在前面加上元注解，用以表示注解的使用方式及范围。 使用例子@MethodInfo(comments = &quot;test method&quot;, author = &quot;dongxiawu&quot;, date = &quot;2018-04-18&quot;, version = 1) public String testMethod() { return &quot;test method&quot;; } 注意事项 接口中有默认值的属性，在使用时可以忽略，而没有默认值的属性则不能忽略，否则会报错。 注解解析基本原理在代码中解析注解需要使用Java的反射机制，但只能解析 Retention 为 RetentionPolicy.RUNTIME 的注解。 例子public class Main { public static void main(String[] args){ for (Method method : Main.class.getMethods()){ if (method.isAnnotationPresent(MethodInfo.class)){ MethodInfo methodInfo = method.getAnnotation(MethodInfo.class); System.out.println(&quot;comments: &quot; + methodInfo.comments() + &quot; author: &quot; + methodInfo.author() + &quot; date:&quot; + methodInfo.date() + &quot; version: &quot; + methodInfo.version()); } } } @MethodInfo(comments = &quot;test method&quot;, author = &quot;dongxiawu&quot;, date = &quot;2018-04-18&quot;, version = 1) public String testMethod() { return &quot;test method&quot;; } } 注解处理器在运行时进行注释解析只能解析只能解析 Retention 为 RetentionPolicy.RUNTIME 的注解，对于 Retention 为 RetentionPolicy.SOURCE 和 RetentionPolicy.CLASS 的注解由于分别在编译完成后和加载到JVM时消除了，所以不能在运行时获取到，这时就需要注解处理器，在编译器是能够获取注解并进行相应操作。 概念注解处理器(Annotation Processor)是javac内置的一个用于编译时扫描和处理注解(Annotation)的工具。简单的说，在源代码编译阶段，通过注解处理器，我们可以获取源文件内注解(Annotation)相关内容。 用途由于注解处理器可以在程序编译阶段工作，所以我们可以在编译期间通过注解处理器进行我们需要的操作。比较常用的用法就是在编译期间获取相关注解数据，然后动态生成.java源文件（让机器帮我们写代码），通常是自动产生一些有规律性的重复代码，解决了手工编写重复代码的问题，大大提升编码效率。 另外一点好处就是由于是在编译器对代码进行处理，所以对代码的运行效率没有影响。（如果是在运行时对注解进行处理，如Retention 为 RetentionPolicy.RUNTIME 的注解，则会占用运行时间） 使用方法 定义自己的注解处理器，首先要继承 Processor 接口，不过为了不实现接口的全部方法，可以选择继承 AbstractProcessor 抽象类，并实现 process 方法。 在编译期间使用自己定义的注解处理器，主要有两种方法： 使用 -processor 选项指定注解处理器的位置，如 javac -processor Myprocessor Main.java 将注解处理器打包成jar包，并采用-processorpath等选项指定路径，如javac -processorpath processor.jar Main.java，同时还需要在 jar 包中添加自定义的 processor 类名信息，以便编译过程中能够找到正确的 Processor，具体方法为：在 META-INF/services/ 文件夹下新建 javax.annotation.processing.Processor 文件，并在其中添加对应的 processor 类名信息。 注：也可以使用 gradle 自动构建，如google 的 com.google.auto.service:auto-service 库 使用例子@Target(ElementType.TYPE) @Retention(RetentionPolicy.SOURCE) @Documented public @interface Persistent { String table(); } @Target(ElementType.FIELD) @Retention(RetentionPolicy.SOURCE) @Documented public @interface Id { String column(); String type(); String generator(); } @Documented @Target(ElementType.FIELD) @Retention(RetentionPolicy.SOURCE) public @interface Property { String column(); String type(); } @Persistent(table = &quot;persion_inf&quot;) public class Persion { @Id(column = &quot;person_id&quot;, type = &quot;integer&quot;, generator = &quot;identity&quot;) private int id; @Property(column = &quot;person_name&quot;, type = &quot;string&quot;) private String name; @Property(column = &quot;person_age&quot;, type = &quot;integer&quot;) private int age; public Persion(){ } public Persion(int id, String name, int age){ this.id = id; this.name = name; this.age = age; } } @SupportedSourceVersion(SourceVersion.RELEASE_8) @SupportedAnnotationTypes({&quot;Persistent&quot;,&quot;Property&quot;,&quot;Id&quot;}) public class MyProcessor extends AbstractProcessor { Elements elementUtils; @Override public synchronized void init(ProcessingEnvironment processingEnv) { super.init(processingEnv); elementUtils = processingEnv.getElementUtils(); } @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) { PrintStream ps = null; try { for (Element t : roundEnv.getElementsAnnotatedWith(Persistent.class)){ Name clazzName = t.getSimpleName(); Persistent per = t.getAnnotation(Persistent.class); ps = new PrintStream(new FileOutputStream(clazzName + &quot;.txt&quot;)); ps.println(&quot;table: &quot; + per.table()); for (Element f : t.getEnclosedElements()){ if (f.getKind() == ElementKind.FIELD){ Id id = f.getAnnotation(Id.class); if (id != null){ ps.println(&quot;id: &quot; +&quot; name: &quot; + f.getSimpleName() +&quot; column: &quot; + id.column() + &quot; type: &quot; + id.type() + &quot; generator: &quot; + id.generator()); } Property property = f.getAnnotation(Property.class); if (property != null){ ps.println(&quot;property: &quot; +&quot; name: &quot; + f.getSimpleName() +&quot; column: &quot; + property.column() + &quot; type: &quot; + property.type()); } } } } }catch (Exception e){ e.printStackTrace(); }finally { if (ps != null){ try { ps.close(); }catch (Exception e){ e.printStackTrace(); } } } return true; } } 编译命令 javac -processor MyProcessor Persion.java 结果输出一个文件，内容为： table: persion_inf id: name: id column: person_id type: integer generator: identity property: name: name column: person_name type: string property: name: age column: person_age type: integer 注意事项自定义注解处理器前可以加上三个注解 @SupportedSourceVersion()：支持版本 @SupportedAnnotationTypes()：支持的注解 @SupportedOptions()：支持的选项]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>注解处理器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android权限管理]]></title>
    <url>%2F2018%2F04%2F16%2FAndroid%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 我们知道，在Android 6.0之前，当我们的应用需要某项权限时，只要在 AndroidManifest.xml 中添加对应的权限就好了。安装应用的时候会列出所有应用要求的权限，只有同意了才能继续安装。这样做虽然比较简单，但是却有两个比较大的缺点： 安装时列出的权限通常比较多，用户往往没有仔细看就点了同意，这样就让应用获取了一些非必须的权限，并利用这些权限非法收集用户信息，这也是 Android 被大众所诟病的原因之一。 如果用户并不想赋予应用某些权限，那么应用就不能安装，这种交互逻辑影响了用户体验，因为有些权限并不是运行应用必须的，或者说没有该权限应用一样可以运行。 因此，从 Android 6.0 开始，Google 改变了 Android 的权限处理逻辑。大致逻辑如图所示：从图中我们可以看出，Google把权限分成两类，具体为： Normal：普通的权限，如网络，获取时区等，具体普通权限的列表可以在网上找到。处理这些权限如同的方式Android 6.0之前一样，只要在 AndroidManifest.xml 中添加对应的权限就好了。 Dangerous：危险的权限，如打电话，获取联系人，读写SD卡等，这些权限在Android 6.0 后在 AndroidManifest.xml 中设置是无效的，必须在运行的时候动态获取，因此也称为动态权限。但是要注意的是，所有危险权限中有两个特殊的权限，即悬浮框权限和运行修改系统设置权限，这两个权限不能动态获取，必须引导用户自己到设置界面进行设置才能生效。 因此在 Android 6.0 之后，安装应用程序时不会列出所有的权限了，而是在使用应用的过程中动态获取。用户没有授权一些非必要的权限也不会导致用户的崩溃。这样一来既提高了用户体验，也让用户的数据更加安全。但也同时带来了开发难度加大的缺点，我们来梳理一下动态权限的逻辑。 在需要某个危险权限的时候，需要首先判断是否已经获得了该权限，如果没有，则应该弹出对话框询问用户是否授权。 当用户拒绝授权的时候，应该判断该权限是否必须的，从而判断是退出程序还是继续运行。 当用户曾经拒绝过该权限时，还应该考虑是否向用户解释为什么需要该权限，以便让用户顺利授权。具体方法为shouldShowRequestPermissionRationale(String permission)。当第一次申请该权限时，返回false，当第二次及以上申请该权限时，返回true。若用户已经选择了不再提示，则返回false。 若用户选择了不再提示，则下次需要该权限时，应该提醒用户手动到设置界面进行设置，因为这个时候权限授权对话框将不再弹出。 注： 由于 Android 的开放性，各个厂家都对系统做了修改，在实际使用过程中发现，有些手机即使查询到某权限已经授权，但在使用过程中还是会发生错误。针对这种情况，可以先尝试用代码测试是否改权限真正授权了（申请联系人权限时尝试如写入一个测试联系人数据）。如果失败，则弹出对话框或引导用户进行授权。]]></content>
      <categories>
        <category>Android权限管理</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[butterknife详解之源码结构分析]]></title>
    <url>%2F2018%2F02%2F14%2Fbutterknife%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 学习完 butterknife 的基本使用之后，本文主要讲解 butterknife 源码的组织结构。 源码构成首先我们来看一下 butterknife 的源码构成。 其中 butterknife ;主模块，提供android使用的API butterknife-annotations; 注解模块，提供了所需的注解 butterknife-compiler；注解编译模块，提供了编译时用到的注解的处理器 butterknife-gradle-plugin；插件模块，自定义的gradle插件，辅助生成有关代码 butterknife-integration-test；该项目的测试用例模块 butterknife-lint；该项目的静态代码检查模块 sample；demo 从源码组成结构我们可以看出，库的结构非常清晰，基本上按功能分成了7个模块。 butterknife模块结构 可以看到，butterknife模块一共只有5个类，而且供客户端使用的只有 Butterknife 和 Unbinder 两个类，可以说将设计原则都应用得淋漓精致。 DebouncingOnClickListener:按钮去抖，其原理时每次按钮按下时禁止按钮短时间内重复按下，处理按钮事件同时另起一个线程重新使能按钮。核心代码为： @Override public final void onClick(View v) { if (enabled) { enabled = false; v.post(ENABLE_AGAIN); doClick(v); } } ImmutableList 将视图数组转换成不可变链表，该方法比系统自带的方法 Collections.unmodifiableList(); 轻量 Utils 实用方法，主要供生成的代码使用，如获取系统资源等。 Unbinder 控件解绑接口，当控件不再使用时应该解绑，避免内存泄露。 Butterknife 从 Butterknife 的方法列表中可以看出 Butterknife类主要做了两件事 绑定(bind)： 其中，绑定的对象可以是 View、Activity、Dialog 其步骤及原理是： 将 Activity、Dialog、View 等提供控件信息的对象等作 target 参数。 从 Activity、Dialog、View 等中找到根视图作为 source 参数。 生成一个类，类名为 target_ViewBinding，该类持有 target 引用，并实现 Unbinder 接口。 从 target 引用中获取控件名和对应的布局id，从 source 中找到对应视图，进行绑定。 应用(apply)将 Action、Setter、Property 等操作应用在对应的控件上。其原理是实现 Action、Setter、Property 等接口，并通过ButterKnife.apply()方法应用在对应的控件上。 到这里 butterknife模块结构 就全部介绍完毕了。下一节介绍 butterknife 的注解系统。]]></content>
      <categories>
        <category>butterknife</category>
      </categories>
      <tags>
        <tag>butterknife</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[butterknife详解之butterknife的基本使用]]></title>
    <url>%2F2018%2F02%2F13%2Fbutterknife%E8%AF%A6%E8%A7%A3%E4%B9%8Bbutterknife%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[butterknife 是有 Android 之神之称的 JakeWharton 开发的一个依赖注入框架，可以帮助开发者快速地完成初始化控件等重复性工作。其原理是通过注解处理器生成中间代码完成控件初始化工作。关于 butterknife 的更多信息可以访问其主页：butterknife主页 版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 本文主要讲解 butterknife 的基本使用 安装 在 android 工程的构建脚本下添加如下内容并点击同步 dependencies { compile &apos;com.jakewharton:butterknife:8.8.1&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos; } 使用butter主要有一下的使用场景 绑定Activity 新建工程，布局如下： 声明控件，代码如下： @BindView(R.id.text1) TextView textView1; @BindView(R.id.text2) TextView textView2; @BindView(R.id.text3) TextView textView3; 绑定控件，代码如下： @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mUnbinder = ButterKnife.bind(this); } 测试效果 textView1.setText(&quot;I am text1&quot;); textView2.setText(&quot;I am text2&quot;); textView3.setText(&quot;I am text3&quot;); 解绑使用完毕之后需要对控件进行解绑定 protected void onDestroy() { super.onDestroy(); mUnbinder.unbind(); } 绑定Fragment 绑定Fragment和绑定Activity基本一样，只是把绑定的步骤放在onCreateView()方法中，代码如下： public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment View root = inflater.inflate(R.layout.fragment_main, container, false); mUnbinder = ButterKnife.bind(this, root); textView1.setText(&quot;I am text1&quot;); textView2.setText(&quot;I am text2&quot;); textView3.setText(&quot;I am text3&quot;); return root; } 绑定多个控件@BindViews({ R.id.first_name, R.id.middle_name, R.id.last_name }) List&lt;EditText&gt; nameViews;//nameViews的集中中添加了三个edittext对象 绑定资源 绑定字符串 @BindString(R.string.title) String title; 绑定图形 @BindDrawable(R.drawable.graphic) Drawable graphic; 绑定颜色 @BindColor(R.color.red) int red; 绑定长度 @BindDimen(R.dimen.spacer) Float spacer; 绑定OnCLick事件@OnClick(R.id.button) void onClick(){ Toast.makeText(this,&quot;on click&quot;,Toast.LENGTH_SHORT).show(); } 一次性改变集合中所有对象的值@BindViews({ R.id.first_name, R.id.middle_name, R.id.last_name }) List&lt;EditText&gt; nameViews; ButterKnife.Action&lt;View&gt; DISABLE = new ButterKnife.Action&lt;View&gt;() { @Override public void apply(@NonNull View view, int index) { view.setEnabled(false); } }; ButterKnife.Setter&lt;View,Boolean&gt; ENABLE = new ButterKnife.Setter&lt;View, Boolean&gt;() { @Override public void set(@NonNull View view, Boolean value, int index) { view.setEnabled(value); } }; ButterKnife.apply(nameViews,DISABLE); ButterKnife.apply(nameViews,ENABLE,false); 使用插件在使用 butterknife 的过程中，可以使用插件快速生成注解 AndroidStudio -&gt; Settings -&gt; Plugin -&gt; Brouse repositories -&gt; butterknife 重启AndroidStudio 要生成注解的布局 -&gt; 右键 -&gt; Generate -&gt; Generate Butterknife Injections 指定控件和对应的变量名 注意事项 控件不能是不能是 static 或者 private 的]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>butterknife</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之迭代器模式]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 迭代器模式：提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 迭代器模式（Iterator）是我们在日常编程时经常使用到的模式，比如在遍历某个List或者Map的时候。 首先我们来看一下迭代器模式的 UML 图 从 UML 图中我们可以看出迭代器模式的几个特点： 迭代器是一个接口，定义了遍历聚合对象的操作，比如next()方法。 由具体的聚合类实现各自的迭代器，从而把迭代操作的具体实现屏蔽起来。 所有的聚合类都有生成迭代器的方法可以生成对应的迭代器。 分析完迭代器模式的特点，我们可以通过一个简单的例子来具体说明迭代器模式是如何工作的。 假设我们要使用迭代器模式遍历一个名字列表，首先应该创建迭代器结构，定义了如何遍历列表。 public interface Iterator { boolean hasNext(); Object next(); } 接下来定义容器类接口，包含了生成迭代器的方法 public interface Container { Iterator getIterator(); } 接下来定义具体的容器类，每个容器类各自实现对应的迭代器类 public class NameRepository implements Container { public String names[] = {&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;}; @Override public Iterator getIterator() { return new NameIterator(); } private class NameIterator implements Iterator { int index; @Override public boolean hasNext() { if(index &lt; names.length){ return true; } return false; } @Override public Object next() { if(this.hasNext()){ return names[index++]; } return null; } } } 这样我们就可以简单地实现遍历名字列表的功能了 public class Main { public static void main(String[] agrs){ NameRepository namesRepository = new NameRepository(); for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){ String name = (String)iter.next(); System.out.println(&quot;Name : &quot; + name); } } } 可能到这里你会有一个疑问，我可以直接使用数组存放名字，然后通过数组下标遍历名字，这样不是更加简单吗？当然可以，但是我们说好的程序应该有以下几个特点： 易于扩展 耦合性低 如果你用了数组实现了遍历，那么如果下一次需要添加一个删除某个位置插入或删除一个名字的功能，那么用数组实现的复杂度是O(n)，而用链表实现的复杂度是O(1)，这个时候你可能会想使用链表来实现，但是你前面的所有功能都是基于数组实现的，所以你不得不全部重写一遍。而如果你使用了迭代器模式，因为客户端只是使用了getIterator()方法生成迭代器，并没有暴露出具体的实现，所以只需要修改聚合类内部的迭代器实现就可以了。 但是迭代器模式也有一些缺点 由于每一个具体的聚合类都要实现对应的迭代器，所以代码量会比较多，略显繁琐。 由于迭代器提供了一种方法去访问聚合类的元素，在一定程度上破坏了聚合类的封闭性。 最后，如果你去仔细看看 Java 的源码，会发现其实 Java 源码已经实现了迭代器模式了。其中 Collection 接口就是聚合类接口， Iterator 接口就是迭代器接口，List，Map等类就是具体的聚合类，每个聚合类内都实现了各自的迭代器类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之组合模式]]></title>
    <url>%2F2018%2F02%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 组合模式（Composite）允许你将对象组合成树形结构来表现“整体/部分”层次结构。 说到组合模式，Android 开发者们第一反应都会想到 View/ViewGroup。没错，View/ViewGroup 正是通过组合模式使用户能够以树状的形式访问它们。那么组合模式究竟是如何实现的呢？首先看一下组合模式的 UML 图。 假设我们现在有这么一个需求：需要按部门和等级建立公司的人员结构图，由于公司的组织结构和人员变动随时都有可能发生，所以，所以不能采用一个固定的数据结构。这种情况下使用组合模式是一个很好的选择。 我们尝试从组合模式的UML中找找编程的灵感。我们可以发现组合模式存在着一下几个特点： 叶子类和非叶子类都继承自同一个组合类 叶子类和非叶子类有针对性地继承组合父类的某些方法。 接着尝试用组合模式解决我们的需求。假设将所有员工分为两类，领导和员工，领导有雇佣和开除员工的权限，而员工有执行具体任务的业务能力。首先新建公共父类，拥有员工和领导的所有方法。 public class Component { protected String name; List&lt;Component&gt; subordinate; public Component(String name){ this.name = name; subordinate = new ArrayList&lt;&gt;(); } public void add(Component c)//增加成员 { throw new UnsupportedOperationException(&quot;该员工不支持此操作&quot;); } public void remove(Component c){ //删除成员 throw new UnsupportedOperationException(&quot;该员工不支持此操作&quot;); } public Component getChild(int i){ //获取成员 throw new UnsupportedOperationException(&quot;该员工不支持此操作&quot;); } public void operation(){ //业务方法 throw new UnsupportedOperationException(&quot;该员工不支持此操作&quot;); } public List&lt;Component&gt; getSubordinate() { return subordinate; } @Override public String toString() { return name; } public void printAll(){ System.out.println(this); for (Component employee : this.getSubordinate()) { employee.printAll(); } } } 接着建立领导类和职员类 public class Employer extends Component { public Employer(String name){ super(name); } public void add(Component c)//增加成员 { subordinate.add(c); } public void remove(Component c){ //删除成员 subordinate.remove(c); } public Component getChild(int i){ //获取成员 return subordinate.get(i); } } public class Employee extends Component { public Employee(String name){ super(name); } @Override public void operation() { System.out.println(&quot;员工执行业务操作&quot;); } } 最后我们就可以简单地实现访问所有的员工了 public class Main { public static void main(String[] agrs){ Employer CEO = new Employer(&quot;John&quot;); Employer headSales = new Employer(&quot;Robert&quot;); Employer headMarketing = new Employer(&quot;Michel&quot;); Employee clerk1 = new Employee(&quot;Laura&quot;); Employee clerk2 = new Employee(&quot;Bob&quot;); Employee salesExecutive1 = new Employee(&quot;Richard&quot;); Employee salesExecutive2 = new Employee(&quot;Rob&quot;); CEO.add(headSales); CEO.add(headMarketing); headSales.add(salesExecutive1); headSales.add(salesExecutive2); headMarketing.add(clerk1); headMarketing.add(clerk2); //打印该组织的所有员工 CEO.printAll(); } } 最后说一下组合模式的优缺点： 优点： 高层模块调用简单，由于不管是树枝还是叶子，对于高层来说都是 Component，所以对调用者来说没有任何区别。 节点自由增减，从代码中可以看出，如果想要在某个节点下新增节点，只要找到父节点就好了，非常容易扩展，符合开闭原则，对以后的维护非常有利。 缺点： 设计复杂，客户端需要花更多时间理清类之间的层次关系。（这个是几乎所有设计模式所面临的问题）。 指向不明，由于对于调用者来说，并不清楚当前节点是树枝还是树叶。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件分析工具-understand]]></title>
    <url>%2F2018%2F01%2F28%2F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-understand%2F</url>
    <content type="text"><![CDATA[Read The Fucking Source Code. Linus Benedict Torvalds 版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 不知道各位平时有没有阅读系统源码或者项目的习惯，毕竟连 Linux 的创造者 —— Linus 老人家都鼓励我们多去阅读源码。但是一想到一些源码动辄上万行的代码量，真的有耐心一直坚持阅读的人又有多少呢？而且源码毕竟是别人写的，有时候只看源码想要理解作者的意图还是有点困难的。那么有没有什么办法能够提高我们阅读源码的速度，或者能够帮助我们理解作者的意图呢？ 我们平时阅读源码的时候，一行一行地读肯定不是最有效的方式，总结一下我们阅读源码的目的主要有以下几点： 了解功能实现方式 学习代码组织形式 在原有基础上增加功能 再来看一下我们阅读源码的时候最希望知道的东西有什么 这个类是干什么的，哪些类使用了这个类 这个方法是干什么的，它修改了那些变量 这个变量有什么用，哪个方法里修改了这个变量 所以到这里我们可以推导出如何快速有效地阅读源码了 阅读文档。读源码时阅读文档可以帮助我们了解这个库，类，方法等的功能和使用场景，能够是我们对源码有大致的了解。 阅读注释。优秀的源码必定带有大量的注释，通过注释我们可以了解类的实现原理、方法的功能等。 看类名，方法名，变量名等。好的源码可以用过变量名等就可以知道大概的作用，这也叫做“注释式编程”。 学习设计模式。绝大部分源码有运用了设计模式，设计模式也被称为开发人员的共同语言。了解设计模式能够让你快速地知道源码作者的意图和代码组织结构。 以上说的都是一些我们阅读源码需要修炼的“硬功夫”，需要一步一个脚印地去学习，去进步。但是有一些工具却能够加快我们学习地脚步。比如一个叫做 Understand 的代码分析工具。 我们先来看看这个工具的效果。比如当我想看看这个类有哪些变量和方法时，它是这样的： 当我想看看某个方法被哪些方法调用了，它是这样的： 当我想看看某个方法的工作流程，它是这样的： 当我想看看某个方法的时序图时，它是这样的： 而且，我们可以通过点击图上的任意方法和类实现跳转，简直就是把代码变成流程图有木有。难怪 Understand 的宣传语就是“让你看代码一目十行”。 到这里，你应该知道 Understand 的作用了，Understand集成了代码编辑器，代码跟踪器和代码分析器，提供了很强大的界面，将分析结果以各种形式（图形、图表、架构图等）呈现给用户，能很大程度的方便程序员进行开发，维护，调试其代码。 Understand 有一下特点 支持多语言：Ada, C, C++, C#, Java, FORTRAN, Delphi, Jovial, and PL/M ，混合语言的project也支持 多平台： Windows/Linux/Solaris/HP-UX/IRIX/MAC OS X 代码语法高亮、代码折迭、交叉跳转、书签等基本阅读功能。 可以对整个project的architecture、metrics进行分析并输出报表。 可以对代码生成多种图（butterfly graph、call graph、called by graph、control flow graph、UML class graph等），在图上点击节点可以跳转到对应的源代码位置。 提供Perl API便于扩展。作图全部是用Perl插件实现的，直接读取分析好的数据库作图。 内置的目录和文件比较器。 支持project的snapshot，并能和自家的TrackBack集成便于监视project的变化。 看到这里，你是不是迫不及待地想试一下了呢？不过这个软件目前是收费的，而且安装包不能在官网下载到。必须发邮件去申请才能获取下载连接，而且回复时间也不固定，反正我发了一周还没有收到邮件，不过不用怕，在公众号后台回复 ”understand” 可以获取 Understand 的安装包、注册码和使用教程哦。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>软件分析工具</tag>
        <tag>understand</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android无线调试]]></title>
    <url>%2F2018%2F01%2F13%2FAndroid%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 正常来说，我们在调试 Android 应用的时候都需要用 USB 数据线将 Android 设备和电脑连接。但是有的时候我们的应用需要通过 USB 来连接外设，或者担心 USB 接口松动，这个时候就可以使用使用 Android 无线调试功能。 前提条件 手机打开 USB 调试功能 找到 手机 -&gt; 设置 -&gt; 全部参数（关于手机） -&gt; 连续点击版本号5次即可进入开发者模式（不同设备位置有可能有细微差别） 找到 手机 -&gt; 设置 -&gt; 开发者选项 -&gt; 打开 USB 调试功能 添加 adb 到环境变量 windows 我的电脑右键 -&gt; 属性 -&gt; 高级 -&gt; 环境变量 linux 在命令行终端输入 gedit ~/.bashrc 在文本最后添加： PATH=[Android Sdk Root]/platform-tools:$PATH，并保存退出，其中，[Android Sdk Root]是你Android Sdk 的目录 在命令行终端输入 source ~/.bashrc, 使环境变量生效（设置环境变量方法有多种，这里只是其中一种） 检查 adb 版本大于 v1.0.25 在命令行终端 输入 adb –version 即可查看版本号，或者直接输入 adb，第一行即为版本号 查看设备IP 将 Android 设备连接上 WIFI，并且和电脑处于同一路由下 点击 设置 -&gt; 关于手机 -&gt; 状态信息 -&gt; 找到设备IP 具体步骤 将 Android 手机用数据线连接到电脑（必须） 在命令行终端输入 adb tcpip ，其中 为端口号，可以任意指定，如：adb tcpip 5555 在命令行终端输入 adb connect :即可连接上 Android 手机，其中 为 Android 手机ip， 为端口号，adb connect 192.168.1.101:5555 当要断开连接时，在命令行终端输入adb disconnect :，如 adb disconnect 192.168.1.101:5555 插件如果觉得命令行的方式太麻烦，可以使用插件版本 将 Android 手机用数据线连接到电脑（必须） AndroidStudio -&gt; Settings -&gt; Plugin -&gt; Brouse repositories -&gt; ADB WIFI 安装插件（重启生效） AndroidStudio -&gt; Tools -&gt; Android -&gt; ADB WIFI -&gt; ADB USB to WIFI 参考资料： [1] http://blog.csdn.net/daditao/article/details/19077281 [2] http://www.linuxidc.com/Linux/2015-08/121192.htm [3] http://blog.csdn.net/zxw2844/article/details/8560052 [4]http://blog.csdn.net/github_2011/article/details/70738203]]></content>
      <categories>
        <category>Android调试技巧</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>无线调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年度总结]]></title>
    <url>%2F2017%2F12%2F31%2F2017%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 2017年马上就要过去了，这一年，应该是我研究生阶段经历事情最多的一年了。 找实习从2017年过完年后，我便开始复习准备找实习了。中间剧情的跌宕起伏堪比电视连续剧。 先是第一次面试就面试网易游戏，结果一面就跪了。然后就来个人品大爆发，面试阿里连面4面。面到 HR 了，本来以为十拿九稳了，结果通知我面试没通过。接着就是学院第一批面试腾讯的，而且接到邀请去深圳总部面试，然而还是倒在了总监面。然后就连 90% 通过率的华为也挂了。 接下来就慌了，开始盲目的投简历，也不管公司规模和专业对不对口。结果5月初才拿到了第一个实习offer——4399，Unity 开发。 本来本着学习的心态去了 4399 实习，但是发现自己实在不喜欢游戏开发，过了两周我就决定辞职了。就在我刚刚提交离职申请的时候，事情发生了惊天大逆转：我收到了阿里的实习offer。 至次，我的找实习之旅终于结束了。 实习中从7月3号正式入职阿里，到9月5号坐上回家的飞机，中间经历了很多第一次。 第一次做飞机，是从广州白云机场到杭州萧山机场的。由于第一次坐飞机有点紧张。我提前了2个小时到机场，然后就在候机大厅坐了两个小时。 第一次和中介斗智斗勇。由于公司只提供两周的住宿。所以我们必须要自己租房子住。由于实习期间太短，很多人不愿意短租，甚至由于是租房高峰期，连空房子都很难找。结果在闲鱼上找到一间，还是中介挂出来的，8平米，还是阳台隔出来的，一个月1650，加上水电费1800多，没办法，只能硬着头皮租了下来。 中介嘴上说一套，实际做一套，实习快结束了才发现自己上当了。然后就开始和中介斗智斗勇，想方设法的想把押金要回来。结果还好，只损失了几百块。不过这个中介公司我以后再也不信了。 第一次接触实际项目。我在的部门是农村淘宝事业部，我们部门的 app 在我开始实习前几个月并入了手机淘宝，所以我后来都是在手机淘宝上做开发的。手机淘宝有5亿的用户，所以我现在可以说我开发的功能被5亿用户使用了！ 第一次实习答辩。实习结束的时候每个人都有一次答辩，答辩结果直接决定能不能拿到offer。虽然事先准备了挺久了，也有小组内预答辩过，但是正式答辩那天还是挺紧张的。我答辩那天有3个总监级别的老大和 HR 一起面试。说实话，表现我个人觉得一般，所以能拿到 offer 我很感谢他们手下留情，哈哈。 第一次和爸妈去旅行。实习结束的时候，老爸老妈来杭州找我，我们一起去了上海，苏州和杭州逛了一圈。说到他们为什么最后会拗不过我选择出来玩，就是因为老爸觉得我拿不到阿里的转正offer的，不知道下次出来是什么时候了，所以才会决定出来玩。没想到他们来的第一天我就收到阿里的转正成功邮件，所以那几天我们玩得都挺开心的。 校招中我的校招在我坐上从杭州回家的飞机就开始了。 当时我刚上飞机，就接到了微信的面试电话，不过飞机快起飞了，就把面试推迟了，虽然结果也没通过。 在校招过程中，因为有了阿里的实习经历做背书，所以基本上还算比较顺利的，拿到了美团和网易游戏的offer，但是我最终还是选择了阿里，一个是因为我觉得部门的人很nice，而且相对比较自由，公司平台大，能够学到更多的东西，另外一个是因为我知道如果我没有阿里的实习和offer，我的校招之路不可能走得那么顺利。 既然别人都认可阿里，而且我刚好有这个机会，那我为什么不去试一下呢？ 毕业设计校招结束之后，我又马不停蹄地开始了毕业设计，由于我毕业设计题目在5月份换过一次，所以我比别人的进度慢了一点。好在到目前为止已经基本做好了，可以开始毕业论文了。 新年展望经历过找实习和工作之后，才发觉原来要进入社会也是如此艰辛。但是我觉得我是时候进入社会了。希望在2018年里能够 和女朋友早点结束异地 早点发专利，顺顺利利毕业 成为一个合格的程序员，不断进步 做好自己职业的发展规划]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastCV Demo in Android Studio]]></title>
    <url>%2F2017%2F12%2F25%2FFastCV%20Demo%20in%20Android%20Studio%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 最近的项目需要在 Android 手机上进行摄像头视频采集、处理。所以需要使用上计算机视觉的库。一开始选择使用 OpenCV 开源库，具体使用参照我之前的文章AndroidStudio使用OpenCV的三种方式 但是 OpenCV 的速度并不能达到要求，同时无意中发现了一个叫做 FastCV 的计算机视觉库，于是就想试一下。但是发现网络上几乎没有关于 FastCV 的 Demo 在 Android Studio 上成功编译的先例，于是只好利用 google、stackoverflow 和 FastCV 官网的自己自己尝试编译，踩了一些坑，最后终于搞定了。 虽然最终因为某些原因并没有使用 FastCV 的 SDK，但是相信这些经验会对一些人有帮助，所以在这里分享给大家。 FastCV 是一个计算机视觉函数库，可以看做的是迷你版的 OpenCV，是高通公司开发的基于高通芯片的 SDK，目前支持的操作系统有： Android Linux Windows RT Windows Phone 8 FastCV 最大的特点就是快，这是因为高通公司针对自己的芯片做了特别的优化的缘故。缺点也特别明显，就是 FastCV 是闭源的，只提供 API，并不提供源码，而且只能运行在高通的芯片上。 由于 FastCV 已经很久没有更新版本了，上一次更新是 16年3月，所以 FastCV 的 Demo 还是基于 eclipse 的，而且不能直接导入 Android Studio，所以需要移植。 关于 Android JNI 的构建方式，目前有 ndk-build 和 cmake 两种方式，谷歌推荐 cmake，本工程也采用cmake 开发环境: Android Studio3.0 + Ubuntu 16.04 LTS 搭建开发环境 首先在 FastCV 的官网上注册并下载 FastCV SDKhttps://developer.qualcomm.com/software/fastcv-sdk 在下载目录下运行 2.1 修改文件权限 sudo chmod a+x fastcv-installer-android-1-7-1.bin 2.2 安装软件 sudo ./fastcv-installer-android-1-7-1.bin 注意，安装 FastCV SDK 需要电脑已经安装 JDK，并且目前还不支持 JDK9，如果你的电脑安装的是 JDK9，那么请记得先切换一下 JDK 版本 移植 FastCV 代码 新建 Android Studio 工程（我选择移植的是 fastcvdemo 工程，所以新建工程时包名可以仿照 fastcvdemo 工程包名，减少工作量） 将 fastcvdemo/jni 内头文件复制到 project root/app/src/main/cpp/include 文件夹下 将 fastcvdemo/jni 内源文件复制到 project root/app/src/main/cpp/source 文件夹下， 将 fastcvdemo/res 内文件复制到 project root/app/src/main/res 文件夹下 将 fastcvdemo/src 内文件复制到 project root/app/src/main/java 文件夹下 将 sdk root/lib/Android/lib64/libfastcv.a复制到 project root/app/src/main/jniLibs 文件夹下 编写 cmake 脚本为了让 Android Studio 能正确编译我们的程序，需要编写一个脚本告诉 Android Studio 我们的代码结构，这就是 cmake 的作用 在 project root/app 目录下新建 CMakeLists.txt 文件，并添加以下内容: #指定 cmake 的最小版本，确保能使用某些新特性构建项目 cmake_minimum_required(VERSION 3.4.1) #输出详细信息 set(CMAKE_VERBOSE_MAKEFILE on) #设置头文件目录 set(INCLUDE_DIR “${CMAKE_SOURCE_DIR}/src/main/cpp/include”) #设置源文件目录 set(SOURCE_DIR “${CMAKE_SOURCE_DIR}/src/main/cpp/source”) #设置库目录 set(LIBRARY_DIR “${CMAKE_SOURCE_DIR}/src/main/jniLibs”) #包含头文件 include_directories(${INCLUDE_DIR}) #添加 fastcv 静态库 add_library(fastcv-lib STATIC IMPORTED) set_target_properties( fastcv-lib PROPERTIES IMPORTED_LOCATION “${LIBRARY_DIR}/libfastcv.a”) #添加 log 库 find_library( log-lib log ) find_path(GLES2_INCLUDE_DIR GLES2/gl2.h HINTS ${ANDROID_NDK}) include_directories(${GLES2_INCLUDE_DIR}) find_library(GLES2_LIBRARY libGLESv2.so HINTS ${GLES2_INCLUDE_DIR}/../lib) #包含子目录 add_subdirectory(${SOURCE_DIR}) 由于 cmake 具有递归查找功能，所以要在每个包含的子目录下也新建 CMakeLists.txt 文件，具体添加内容查看 Demo 在app目录下的build.gradle 内添加： android { defaultConfig { ... externalNativeBuild { cmake { arguments &quot;-DANDROID_ARM_NEON=TRUE&quot;, &quot;-DVAR_NAME=ARG_1 ARG_2&quot;, &quot;-DANDROID_CPP_FEATURES=rtti exceptions&quot; cppFlags &quot;-std=c++11&quot;, &quot;-frtti&quot;, &quot;-fexceptions&quot; } } ndk { //只支持高通指令集 abiFilters &apos;arm64-v8a&apos; } } externalNativeBuild { cmake{ path &quot;CMakeLists.txt&quot; } } } 总结到这里，就可以正常编译并运行 FastCV Demo 了，Demo 提供的各种图像处理操作都能达到实时性的效果，但是由于 FastCV SDK 的缺点很明显，只支持高通 CPU 和不开源，所以网上资料少也就不奇怪了。 关于FastCV Demo，我上传到了 github上，请自行下载。https://github.com/dongxiawu/FastcvDemo 参考资料： [1] https://developer.qualcomm.com/software/fastcv-sdk [2] https://cmake.org/cmake-tutorial/ [3] https://developer.android.google.cn/studio/projects/add-native-code.html?hl=zh-cn]]></content>
      <categories>
        <category>FastCV</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FastCV</tag>
        <tag>JNI</tag>
        <tag>cmake</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio使用OpenCV的三种方式]]></title>
    <url>%2F2017%2F12%2F14%2FAndroidStudio%E4%BD%BF%E7%94%A8OpenCV%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 最近的项目需要在 Android 手机上使用 OpenCV 开源库，于是到网上找教程。没想到网上的教程大多数是 eclipse 的，还有很多是错的，最后还是靠 Stack Overflow、 OpenCV 官网和 Google 解决了这个问题，在这里记录一下，希望能帮到有需要的人。 要在 Android 上使用 OpenCV，总体上来说有三种方法 使用 OpenCV Manager + OpenCV Android SDK 使用 OpenCV Android SDK + OpenCV 动态库 使用 OpenCV 动态库 + JNI 开发环境: Android Studio3.0 + Ubuntu 16.04 LTS 使用 OpenCV Manager + OpenCV Android SDK这种方法最简单，但是也对用户最不友好，因为需要多安装 OpenCV Manager 这个APK，适合在快速验证功能的时候使用。 其实这种方法的原理就是利用 Android 的 Service 来进行跨进程通信，主要流程如下： 具体操作步骤如下： 新建 Android 工程 下载 OpenCV-Android-SDK，下载地址: https://opencv.org/releases.html 点击 File -&gt; new -&gt; Import Module, 选中 OpenCV-Android-SDK/sdk/java 文件夹,点击确定，就会自动识别处模块，如下图所示： 导入完成后，会在工程目录下发现 OpenCV 的库，settings.gradle 文件也会相应改变 点击 File -&gt; Project Structure，在 Modules 下点击 依赖 OpenCV 的模块（比如 app ），再点击右边的 Dependencies。点击右侧加号选第三个 Module dependency 后选择 openCVLibrary310 后点击完成。 完成后会发现 app目录下的 build.gradle 中的 dependencies 增加了 oepncv 的依赖。到这里，我们就可以在程序里面使用 OpenCV 的类了。 由于 OpenCV 库的版本一般情况下和你的工程的版本号不同，所以需要把 OpenCV 库目录下的 build.gradle 中的编译版本，构建版本等参数设置成和工程一样。 根据手机安装对应的 OpenCV Manager apk，apk 在 OpenCV-Android-SDK/apk 目录下。可以将 apk 复制到手机内存卡里安装，也可以将手机连上电脑，然后通过命令行安装，安装命令：adb install [OpenCV_xxx.apk] 在使用 OpenCV 功能前 使用OpenCVLoader.initAsync(String Version, Context AppContext,LoaderCallbackInterface Callback) 这个方法进行初始化，初始化成功之后就可以正常使用 OpenCV 库了。 使用 OpenCV Android SDK + OpenCV 动态库第一种方法有点就是简单，缺点就是必须要安装 OpenCV Manager apk。要用户同时安装两个 apk 并不太现实，所以第一种方法不适合在实际项目中使用。而采用 OpenCV Android SDK + OpenCV 动态库 的方法就可以避免这个问题。 主要步骤（1-5点都和之前一样）： 新建 Android 工程 下载 OpenCV-Android-SDK，下载地址: https://opencv.org/releases.html 点击 File -&gt; new -&gt; Import Module, 选中 OpenCV-Android-SDK/sdk/java 文件夹,点击确定，就会自动识别处模块，如下图所示： 导入完成后，会在工程目录下发现 OpenCV 的库，settings.gradle 文件也会相应改变 点击 File -&gt; Project Structure，在 Modules 下点击 依赖 OpenCV 的模块（比如 app ），再点击右边的 Dependencies。点击右侧加号选第三个 Module dependency 后选择 openCVLibrary310 后点击完成。 完成后会发现 app目录下的 build.gradle 中的 dependencies 增加了 oepncv 的依赖。到这里，我们就可以在程序里面使用 OpenCV 的类了。 由于 OpenCV 库的版本一般情况下和你的工程的版本号不同，所以需要把 OpenCV 库目录下的 build.gradle 中的编译版本，构建版本等参数设置成和工程一样 将 OpenCV-Android-SDK/sdk/native/libs 目录下全部内容复制到 工程目录/app/src/main/jniLibs 目录下（这里可以针对特定的手机做裁剪，为了方便可以全部复制） 在使用 OpenCV 功能前 使用下面代码加载 OpenCV 动态库 static { System.loadLibrary(&quot;opencv_java3&quot;); } 然后使用 OpenCVLoader.initDebug(); 进行初始化。初始化成功之后，就可以正常使用 OpenCV 进行开发了。 使用 OpenCV 动态库 + JNI第二种方法由于不需要安装 OpenCV Manager，同时又是使用 OpenCV Android SDK 在 Java 层进行开发，故开发速度非常快，十分适合一般的引用场景。但该方法也有几个缺点： 使用 OpenCV Android SDK 会增大 APK 的体积。 由于在 Java 层进行开发，在某些场景下会导致运行效率不高。 因此引出了第三中方法。该方法使用 OpenCV 动态库 + JNI 的方式进行开发，适合在对计算效率要求比较高的场景下使用。，但由于采用了 JNI（Java Native Interface）技术，开发的难度也是最大的。 主要步骤： 新建 Android 工程 下载 OpenCV-Android-SDK，下载地址: https://opencv.org/releases.html 下载相关工具 3.1 在打开的项目中，从菜单栏选择 Tools -&gt; Android -&gt; SDK Manager。 3.2 点击 SDK Tools 标签。 3.3 选中 LLDB、CMake 和 NDK 旁的复选框，如下图所示。 将 OpenCV-Android-SDK/sdk/native/libs 目录下全部内容复制到 工程目录/app/src/main/jniLibs 目录下（这里可以针对特定的手机做裁剪，为了方便可以全部复制） 创建新的原生源文件 要在应用模块的主源代码集中创建一个包含新建原生源文件的 cpp/ 目录，并新建 source 和 include 的子目录。在 source 目录下新建源文件 native-lib.cpp 复制头文件 将 OpenCV-Android-SDK/sdk/native/jni/include 目录下全部内容复制到 工程目录/app/src/main/cpp/include 目录下 编辑 CMakeLists.txt 在模块根目录下新建文件 CMakeLists.txt，并添加以下内容： #指定 cmake 的最小版本，确保能使用某些新特性构建项目cmake_minimum_required(VERSION 3.4.1) #输出详细信息set(CMAKE_VERBOSE_MAKEFILE on) #设置库目录set(LIBRARY_DIRS “${CMAKE_SOURCE_DIR}/src/main/jniLibs”) #包含头文件目录include_directories(src/main/cpp/include) #添加 opencv 的动态库 add_library( libopencv_java3 SHARED IMPORTED ) #指定库路径 set_target_properties( libopencv_java3 IMPORTED_LOCATION “${LIBRARY_DIRS}/${ANDROID_ABI}/libopencv_java3.so” ) #设置源文件目录aux_source_directory(src/main/cpp/source SOURCE_DIR) add_library( native-lib SHARED ${SOURCE_DIR} ) find_library( log-lib log ) target_link_libraries( native-lib libopencv_java3 ${log-lib} ) 修改 build.gradle在模块的 build.gradle 内的 android 闭包内添加： // Encapsulates your external native build configurations. externalNativeBuild { // Encapsulates your CMake build configurations. cmake { // Provides a relative path to your CMake build script. path &quot;CMakeLists.txt&quot; } } 编写 JNI 接口和 C++ 代码。 上面 CMakeLists.txt 的作用是将 opencv 的动态库和 native-lib.cpp 链接起来生成新的动态库。 到目前位置，我们已经能够在 native-lib.cpp 内使用 C++ 编写 OpenCV 程序了。 接下来的步骤为： 在 Java 层编写 native 方法 使用 javah -jni 生成本地接口 在 C++ 层实现接口 在 Java 层调用 native 方法。 由于这部分是普通的 JNI 使用，不属于 opencv 的内容，所以不在这里展开了。 总结到这里，就介绍了 Android 使用 OepnCV 的三种方式。其中我个人推荐第二种方法。 关于第三种方法，我采用的是 cmake 构建，虽然也可以采用 ndk 的方式，但是我个人推荐的是 cmake，因为 cmake 更加简单，应用范围也更广泛，谷歌目前推荐的构建方式也是 cmake。 关于三种方法的 Demo，我上传到了 github上，请自行下载。https://github.com/dongxiawu/OpencvDemo 参考资料： [1] https://www.cnblogs.com/yunfang/p/6149831.html [2] https://docs.opencv.org/2.4/doc/tutorials/introduction/android_binary_package/dev_with_OCV_on_Android.html [3] https://docs.opencv.org/2.4.13.4/platforms/android/service/doc/UseCases.html#first-application-start [4] https://developer.android.google.cn/studio/projects/add-native-code.html?hl=zh-cn [5] https://cmake.org/cmake/help/v3.10/ [6] http://blog.csdn.net/Jason101123/article/details/78600355]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>JNI</tag>
        <tag>cmake</tag>
        <tag>Android Studio</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之生成器模式]]></title>
    <url>%2F2017%2F12%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 生成器模式（Builder）模式，封装一个产品的构造过程，并允许按步骤构造。 生成器模式是日常开发中使用最广的设计模式之一，几乎可以说每个稍微大一点的项目都会用到生成器模式。比如 Android 源码的 AlertDialog，最流行的网络库之一 okhttp 等等。 首先我们看一下生成器模式的 UML 图 生成器模式主要有以下几个优点： 将一个复杂对象用创建过程封装起来。 允许对象通过多个步骤来创建，并且可以改变过程。 向客户隐藏产品内部表现。 产品的实现可以替换。 下面我通过一个简单的例子来讲解一下生成器模式的使用过程和优点。 假设我们要创建一个 Pizza 类，这个 Pizza 类有很多参数，比如尺寸，馅料种类，是否切块等。那么就存在这样的问题，如果我们把所有的参数都写在构造函数里，那么构造函数就会非常长，而且如果我们以后想要添加其他参数的话，改起来也会比较麻烦。还有一种方法就是先创建出 Pizza 对象，然后再用 setter 方法设置参数，但是这样有可能会导致有一些参数忘记设置了，并且这种方法会导致线程安全的问题。这个时候我们就可以使用生成器模式了。 代码如下： public class Pizza { int size = 0; int type = 0; boolean isDiced = false; private Pizza(){ } protected void setSize(int size){ this.size = size; } protected void setStuffType(int type){ this.type = type; } protected void isDiced(boolean isDiced){ this.isDiced = isDiced; } public static class Builder{ int size = 0; int type = 0; boolean isDiced = false; public Builder(){ } public Builder setSize(int size){ this.size = size; return this; } public Builder setStuffType(int type){ this.type = type; return this; } public Builder isDiced(boolean isDiced){ this.isDiced = isDiced; return this; } public Pizza build(){ Pizza pizza = new Pizza(); pizza.setSize(size); pizza.setStuffType(type); pizza.isDiced(isDiced); return pizza; } } } 从代码里我们可以看出几个特点 Pizza 类的构造函数是私有的，也就是说我们不能直接 new 出一个 Pizza 对象，只能通过 Builder 类的 build 方法构建出 Pizza 对象。 Builder 类是 Pizza 类的 静态内部类，也就是说我们可以直接创建出 Builder 对象，而不用先创建出 Pizza 对象。 Builder 类的大部分 setter 方法都和 Pizza 类的 setter 方法一样，但是 Builder 类的 setter 方法是 public 的，而 Pizza 的 setter 方法一般是 private 或者 protected 的。 在 Builder 对象的 build 方法被调用时才真正生成 Pizza 对象。我们可以在 build 方法里做一些控制，比如参数合法性检测，必填参数检测等。 Builder 类的参数和 Pizza 类的参数是一样的，这样无形之中增加了代码的复杂度，也增加了出错的可能行。不过我们可以通过另外的一个参数类 Params 来存放所有参数，具体可以看 Android 源码的 AlertDialog 类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>生成器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2F2017%2F12%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 适配器模式（Adapter）是我们在开发过程中经常会用到的一个设计模式。它的作用是将一个类的接口，转换另一个接口。 那么为什么要进行转换呢？想想生活的例子你就知道了。设想一下，你出国旅游，发现你的手机的充电器不能插进当地的插座，因为标准不同。这时候你会买一个转接器，然后解决了这个问题。这个转接器就是适配器，适配器模式也就是为了解决这一类问题而存在的。 我们回想一下转接器的工作原理：转接器一般由两面组成，一面是适配你的手机充电器插头的插座，另一面是适配当地插座的插头。你将你的手机充电器插进转接器，再将转接器插进当地的插座，就完成了适配。 设配器模式UML图如下： 由此我们可以总结一下适配器模式的要点： 适配器将一个对象包装起来以改变其接口以符合用户要求。 那么我们如何用代码的形式实现适配器模式呢？假设我们现在有这么一个情景：现在手头上有一个遥控，上面有“上”和“下”两个按钮，但是我们希望用它来控制一个风扇的开关，这样就有了一个从“上”和“下”到“开”和“关”的转换。这种情况下就可以用到适配器模式了。 首先是风扇类，非常简单，有 on 和 off 两个方法 public class Fan { public void on(){ System.out.println(&quot;The fan is on&quot;); } public void off(){ System.out.println(&quot;The fan is off&quot;); } } 接着是遥控类，也非常简单，有 up 和 down 两个 方法 public class Controler { public void up(){ System.out.println(&quot;The up button is pressed&quot;); } public void down(){ System.out.println(&quot;The down button is pressed&quot;); } } 接着就是我们的适配器接口，上面和风扇一样有 on 和 off 两个方法。 public interface Adapter { void on(); void off(); } 接下来，我们把遥控和适配器组合起来，变成了风扇遥控器，按下 up 按钮就是风扇开，按下 down 按钮就是风扇关。 public class FanControler extends Controler implements Adapter { private Fan mFan; public FanControler(Fan fan){ mFan = fan; } @Override public void up() { on(); } @Override public void down() { off(); } @Override public void on() { mFan.on(); } @Override public void off() { mFan.off(); } } 接下来我们就可以运行起来了： public class Main { public static void main(String[] agrs){ Fan fan = new Fan(); Controler fanControler = new FanControler(fan); fanControler.up(); fanControler.down(); } } 运行结果如下： The fan is on The fan is off 由此可见，我们成功地将只有上和下两个按钮的遥控转换成了能够控制风扇开关的遥控器。 总结一下： 适配器模式能够将一个接口转换成另一个接口。具体是通过实现待转换的接口，同时持有目标接口，在内部进行接口转换实现的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F2017%2F12%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 策略模式（Strategy）：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 相信我们很多人小时候都玩过一款叫做「 魂斗罗 」的游戏吧。在游戏里，人物可以获取不同的武器，从而打出不同类型、威力的子弹。那么，这在程序上是如何设计的呢？ 首先想到的可能是可以用 if-else 或者 switch 的方式，列出所有可能的武器类型，比如下面的例子。 public class Soldier { private int gunType = -1; public static final int PISTOL = 1; public static final int RIFLE = 2; public void setGunType(int gunType) { this.gunType = gunType; } public int getGunType() { return gunType; } public void shoot(){ switch (gunType){ case PISTOL: System.out.println(&quot;射出手枪子弹&quot;); break; case RIFLE: System.out.println(&quot;射出步枪子弹&quot;); break; default:break; } } } public class Main { public static void main(String[] args) { // write your code here Soldier soldier = new Soldier(); soldier.setGunType(Soldier.PISTOL); soldier.shoot(); soldier.setGunType(Soldier.RIFLE); soldier.shoot(); } } 输出的结果为： 射出手枪子弹 射出步枪子弹 这种办法最大的缺点就是每次要新增或者要删除一种武器的时候，都要对士兵类进行修改，这就违背了「 对扩展开发，对修改关闭 」的设计原则。 其实遇到这种类型的问题，我们可以用「 策略模式 」解决。UML类图如下： 那么用策略模式解决上面的「 魂斗罗 」问题，代码如下： public class Soldier { private Gun gun; public void setGun(Gun gun) { this.gun = gun; } public Gun getGun() { return gun; } public void shoot(){ if (gun != null){ gun.fire(); } } } public interface Gun { void fire(); } public class Rifle implements Gun { @Override public void fire() { System.out.println(&quot;射出步枪子弹&quot;); } } public class Pistol implements Gun { @Override public void fire() { System.out.println(&quot;射出手枪子弹&quot;); } } public class Main { public static void main(String[] args) { // write your code here Soldier soldier = new Soldier(); Gun pistol = new Pistol(); Gun rifle = new Rifle(); soldier.setGun(pistol); soldier.shoot(); soldier.setGun(rifle); soldier.shoot(); } } 主要思路就是将 枪支 独立出来成为一个接口，每种类型的枪都实现这个接口，士兵 类持有枪支接口，并将具体的操作委托给枪支接口。 由此我们可以总结出「 策略模式 」一个很重要的特点就是：把变化的部分抽离出来。这实际上也是很多设计模式的指导思想。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之观察者模式]]></title>
    <url>%2F2017%2F11%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 观察者模式（Observer）又称为发布-订阅（Publish-Subscribe）模式，它定义了对象之间一对多的依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 观察者模式是日常开发中使用最广的设计模式之一，有许多开源库也用到了观察者模式，比如说： Rxjava，EventBus 等等。 观察者模式主要有以下几个特点： 观察者模式定义了对象之间一对多的关系 观察者和被观察者之间用松耦合的方式 观察者接收通知有两种方式，推和拉（推被认为更加正确） 那么怎么使用观察者模式呢？举一个例子 目前很火的微信公众号相信大家都不陌生，当我们关注了某一个公众号的之后，每当公众号有新文章的时候，我们都会自动接收到更新。但是公众号博主并不需要知道关注他公众号的每一个人究竟是谁。当我们想看这个公众号更多的文章时候，还可以点击「 历史文章 」进行查看。当我们取消对某一个公众号的关注之后，不管这个公众号以后有多少文章更新，我们都不会再收到了，除非我们再次关注这个公众号。 这个公众号的例子就是一个典型的观察者模式的应用实例。从这个例子里我们可以总结出观察者模式的使用流程。 注册（当我们关注了某个公众号的时候，实际上就是完成了注册的流程，我们告诉了该公众号「 我关注了你，以后你有新文章记得推送给我 」。） 通知（当我们接收到该公众号的新文章的时候，实际上就是完成了通知的流程，公众号告诉了我们「 我新发表了一篇文章，记得查收哦 」。） 拉取（当我们想查看该公众号更多的文章，点击了「历史文章」或其他按钮的时候，实际上就是完成了拉取的过程，我们告诉了该公众号「 我想看你其他的文章，你把链接发给我一下 」。） 解注册（当我们取消对某个公众号的关注的时候，实际上就是完成了解注册的流程，我们告诉了该公众号「 我不想再看你写的文章了，你以后都别推送给我了 」。） 接下来，我们通过一个简单的例子实现一下观察者模式 public interface Observer { void update(Observerable observerable, Object obj); } public interface Observerable { void addObserver(Observer observer); void removeObserver(Observer observer); void notifyObservers(); } public class Publisher implements Observerable { private String publisherName; private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;(); private List&lt;String&gt; articles = new ArrayList&lt;&gt;(); private String latestArticle = null; public Publisher(@NotNull String name){ publisherName = name; } public String getPublisherName() { return publisherName; } @Override public void addObserver(Observer observer) { if (!observers.contains(observer)){ observers.add(observer); } } @Override public void removeObserver(Observer observer) { if (observers.contains(observer)){ observers.remove(observer); } } @Override public void notifyObservers() { for (Observer observer : observers){ observer.update(this,latestArticle); } } public void addNewArticle(String articleName){ articles.add(articleName); latestArticle = articleName; notifyObservers(); } public List&lt;String&gt; getArticleList(){ return articles; } } public class Reader implements Observer { private String readerName; List&lt;Publisher&gt; publishers = new ArrayList&lt;&gt;(); public Reader(@NotNull String name){ readerName = name; } public void follow(Publisher publisher){ if (!publishers.contains(publisher)){ publishers.add(publisher); publisher.addObserver(this); System.out.println(&quot;读者： &quot; + readerName + &quot; 关注公众号：&quot; + publisher.getPublisherName()); } } public void unfollow(Publisher publisher){ if (publishers.contains(publisher)){ publishers.remove(publisher); publisher.removeObserver(this); System.out.println(&quot;读者： &quot; + readerName + &quot; 取消关注公众号：&quot; + publisher.getPublisherName()); } } @Override public void update(Observerable observerable, Object obj) { System.out.println(&quot;读者： &quot; + readerName + &quot; 接收到公众号: &quot; + ((Publisher)observerable).getPublisherName() + &quot;的新文章： &quot; + (String)obj); } public void getAllArticleByPublisher(Publisher publisher){ if (publishers.contains(publisher)){ publisher.getArticleList(); System.out.println(&quot;读者： &quot; + readerName + &quot; 获取公众号: &quot; + publisher.getPublisherName() + &quot;的所有文章&quot;); }else { System.out.println(&quot;没有关注该公众号&quot;); } } } public class Test { public static void main(String[] args){ Publisher publisherA = new Publisher(&quot;公众号１&quot;); Publisher publisherB = new Publisher(&quot;公众号２&quot;); Reader readerA = new Reader(&quot;读者１&quot;); Reader readerB = new Reader(&quot;读者２&quot;); readerA.follow(publisherA); publisherA.addNewArticle(&quot;设计模式之观察者模式&quot;); readerB.follow(publisherA); publisherA.addNewArticle(&quot;设计模式之单例模式&quot;); publisherB.addNewArticle(&quot;设计模式之策略模式&quot;); readerA.follow(publisherB); readerA.unfollow(publisherA); readerA.getAllArticleByPublisher(publisherA); readerA.getAllArticleByPublisher(publisherB); } } 通过上面的代码，我们就可以模拟出公众号和读者的关注，推送，获取，取消关注四个操作。 上面的代码执行结果为： 读者： 读者１ 关注公众号：公众号１ 读者： 读者１ 接收到公众号: 公众号１的新文章： 设计模式之观察者模式 读者： 读者２ 关注公众号：公众号１ 读者： 读者１ 接收到公众号: 公众号１的新文章： 设计模式之单例模式 读者： 读者２ 接收到公众号: 公众号１的新文章： 设计模式之单例模式 读者： 读者１ 关注公众号：公众号２ 读者： 读者１ 取消关注公众号：公众号１ 没有关注该公众号 读者： 读者１ 获取公众号: 公众号２的所有文章 那么什么时候就应该使用观察者模式呢？ 当一个模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。 最后提一点，其实 Java 源码中的 「 java.util.Observer 」和 「 java.util.Observable 」 两个类就帮我们实现了观察者模式，但是有一点不同的是，「 java.util.Observable 」是类而不是接口，而 Java 的单继承机制就导致我们不能在继承「 java.util.Observable 」的时候同时又继承别的类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2017%2F11%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[保证一个类仅有一个实例，并提供一个访问它的全局访问点。 艾迪生维斯理 《设计模式》 版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 概述在我们日常编写程序的时候，经常需要一种这样的对象。我们希望整个系统只有一个这样的对象，不论在什么时候和不论在哪里获取这个对象的时候，获得的都是同一个对象。 比如说系统的任务管理器，我们希望整个系统只有一个任务管理器，不论什么时候打开任务管理器，都可以看到当前系统的所有任务，而不是把任务分散在很多个任务管理器里。 又比如说打印机，当电脑连接上一台打印机的时候，我们会希望不管是在文档A里使用或者在文档B里使用的时候，都是同一台打印机，而且能够按顺序打印。 我们把这种类似的需求不断总结并归纳起来，就成了单例模式。 单例模式可以说是所有设计模式里面最简单的了，但是要灵活并且准确地使用它也不是那么容易的。 首先观察一下单例模式的 UML 图。 从 UML 图中我们可以观察到单例模式的几个特点 私有的、静态的实例对象 私有的构造函数 公有的、静态的获取实例对象的方法 那么，什么样的代码可以同时满足这几个特点呢？ 懒汉模式所谓的懒汉模式，就是一开始并不实例化对象，等到需要使用的时候才实例化。 {% codeblock 懒汉模式 lang:java %} public class Singleton { private static Singleton instance = null; private Singleton(){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } {% endcodeblock %} 从上面的代码我们可以看到，当第一次获取 Singleton 实例的时候，instance 为空，将创建 Singleton 对象，并赋值给 instance 变量。以后的每次一获取都将获得第一次创建的 Singleton 对象，从而实现了唯一性。 线程安全验证仔细想想这段代码，可能存在什么问题呢？ 假设有这么一种情况， Singleton 对象还没有创建，这时候有很多个线程同时获取 Singleton 对象，这时候会发生什么呢？ 用下面的代码可以验证 {% codeblock 懒汉模式 线程安全验证 lang:java %} public class Singleton { private static int count = 0; private static Singleton instance = null; private Singleton(){ try { Thread.sleep(10); }catch (InterruptedException e){ } System.out.println("Singleton 私有构造方法被调用 " + ++count + "次"); } public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } public class Test { public static void main(String[] args){ Runnable runnable = new Runnable() { @Override public void run() { Singleton singleton = Singleton.getInstance(); System.out.println("当前线程：" + Thread.currentThread().getName() + " Singleton: " + singleton.hashCode()); } }; for (int i = 0; i < 10; i++){ new Thread(runnable).start(); } } } {% endcodeblock %} 从上面的代码可以看到，我们对懒汉模式做了一点小修正，在创建 Singleton 对象的时候让当前线程休眠了10ms，这主要是因为计算机运算速度太快了，不让当前线程休眠一下的话很难出现想要的结果。关于休眠我们可以把它想象成创建对象的过程中需要消耗一定的时间。 运算部分结果如下： {% codeblock 懒汉模式 线程安全验证结果 lang:java %} Singleton 私有构造方法被调用 1次 当前线程：Thread-1 Singleton: 2044439889 Singleton 私有构造方法被调用 4次 Singleton 私有构造方法被调用 3次 Singleton 私有构造方法被调用 2次 当前线程：Thread-0 Singleton: 605315508 当前线程：Thread-2 Singleton: 2298428 当前线程：Thread-3 Singleton: 1005746524 当前线程：Thread-4 Singleton: 1005746524 当前线程：Thread-5 Singleton: 1005746524 当前线程：Thread-6 Singleton: 1005746524 当前线程：Thread-7 Singleton: 1005746524 当前线程：Thread-8 Singleton: 1005746524 当前线程：Thread-9 Singleton: 1005746524 {% endcodeblock %} 从上面的结果可以看到，Singleton 的私有构造方法被调用了不止一次。对此的解释是，当第一次获取 Singleton 对象还没完成的时候，线程被系统挂起了，这时候有其他线程刚好也获取了 Singleton 对象，那么就会产生多个 Singleton 对象。 由此我们可以得出结论：懒汉模式是 非线程安全 的。 同步方法为了解决懒汉模式非线程安全的缺点，就出现了改进的懒汉模式。其原理是当多个线程同时获取 Singleton 对象时，一次只让一个线程获取，其他线程都在等待，这样就解决了多线程下的对象获取问题。 {% codeblock 同步方法 lang:java %} public class Singleton { private static Singleton instance = null; private Singleton(){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } {% endcodeblock %} 我们通过 synchronized 关键字让 getInstance()方法一次只能让一个线程调用，但是随着而来的又有另外一个问题。 那就是 效率问题，因为只有第一次获取 Singleton 对象时有可能发生线程安全问题，但是使用同步方法却让每次只让一个线程能访问getInstance()方法，而不管 Singleton 对象是不是已经被创建出来了。 那么有没有办法能同时解决线程安全和效率问题呢？ 双重校验双重校验 方式就是为了解决懒汉模式的线程安全和效率问题而产生的。 {% codeblock 双重校验 lang:java %} public class Singleton { private static Singleton instance = null; private Singleton(){} public static Singleton getInstance() { if (instance == null){ synchronized (Singleton.class){ if (instance == null){ instance = new Singleton(); } } } return instance; } } {% endcodeblock %} 双重校验就是将前面两种懒汉模式结合起来。当第一次获取 Singleton 对象时， instance 为空， 这时候为了解决可能存在的线程安全问题，同步了 Singleton 这个类对象。也就是说，同一时刻只能有一个线程能够执行 synchronized 之后的代码。同时因为同步代码外层有一个条件语句，所以同步代码只有在第一次获取 Singleton 对象的时候执行到，这样就解决了效率问题。 但是这种方法还是有一个问题，那就是 instance = new Singleton() 这一行代码并不是原子性的 具体来说，JVM执行这一行代码时主要做了三件事 给 instance 分配内存空间 调用 Singleton 的构造函数来初始化成员变量 将 instance 变量指向分配的内存空间（执行完这一步之后 instance 就不为 null 了） 由于 JVM 的指令优化存在，上面的第二点和第三点并不能保证一定按顺序执行。也就是说执行顺序有可能为 1-2-3 或者 1-3-2。 假设是 1-3-2，那么如果执行到3的时候，线程被抢占了，有另外一个线程获取了单例对象（这时候 instance 不为 null，但是还没有初始化），那么自然就会出现错误。 为了解决这个问题，我们只要将 instance 变量声明成 volatile 就可以了。 private static volatile Singleton instance = null; volatile 关键字主要有两个特性 可见性：保证线程没有变量的本地副本，每次都去主内存获取最新版本 禁止指令重排序：生成内存屏障 很明显，我们这里利用的是 volatile 的第二个特性。 特别注意的是只有在 Java 5 之后使用这种方式才是完全安全的，原因是 Java 5 之前的 Java 内存模型（Java Memory Model，JMM）存在缺陷，即使变量声明为 volatile 也不能完全避免重排序，这个问题在 Java 5 之后才修复。 恶汉模式这时候我们可以换个思路，既然懒汉模式是因为需要的时候才创建对象，所以才让程序有机会可以产生多个对象。那如果我一开始就把对象创建好了，不就行了吗？这就出现了恶汉模式。 恶汉模式的意思是不管对象目前有没有使用，都会先创建出来。 {% codeblock 恶汉模式 lang:java %} public class Singleton { private static final Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance() { return instance; } } {% endcodeblock %} 从代码中可以看到，由于在 Singleton 类加载时就创建了 Singleton 对象，所以恶汉模式是 线程安全 的。 但是恶汉模式存在的问题就是不管目前对象有没有被使用，都被创建了出来，浪费了内存空间。 静态方法静态方法的单例模式和恶汉模式的原理一样，都是利用了classloader，在类加载的时候就创建了 Singleton 对象。 {% codeblock 静态方法 lang:java %} public class Singleton { private static Singleton instance = null; static { instance = new Singleton(); } private Singleton(){} public static Singleton getInstance() { return instance; } } {% endcodeblock %} 静态内部类静态内部类的方法和上面两种方法既有相似的地方，也有不同的地方。 {% codeblock 静态内部类 lang:java %} public class Singleton { private static class SingletonHolder{ private static final Singleton INSTANCE = new Singleton(); } private Singleton(){} public static Singleton getInstance() { return SingletonHolder.INSTANCE; } } {% endcodeblock %} 从代码种我们可以看到，静态内部类的方法和前两种方法一样，都是利用了classloader，在加载类的时候创建 Singleton 对象。 不同的地方在于加载的类不同。静态内部类方法在加载 Singleton 类的时候不会创建 Singleton 对象。而是在加载 SingletonHolder 类的时候才会。那么 SingletonHolder 类是什么时候加载的呢？ 根据JVM（Java 虚拟机）的类加载规则，静态内部类只有在主动调用的时候才会加载。也就是说，在第一次调用 getInstance() 方法时才会加载 SingletonHolder 类，同时创建了 Singleton 对象。 也可以说，静态内部类的方法利用JVM解决了前两种方法占用内存的问题。 防止单例受到攻击到目前为止，我们所分析的所有单例模式都有一个前提，那就是调用者非常听话地使用了 Singleton.getInstance() 方法获取单例对象。但是在现实生活中是不是都是这样的呢？会不会有不怀好意的人使用其他方式破坏我们的单例模式呢？ 我们先思考一下，获取一个对象有几种方式 使用 new 关键字 通过反射调用 序列化 我们前面的单例模式都是通过第一种方式获取对象的，那么如果采用其他两种方式，之前的单例模式还安全吗？答案是否定的。 反射攻击首先我们来看一下反射调用，以双重检验方式为例 {% codeblock 反射攻击 lang:java %} public class Singleton { private static volatile Singleton instance = null; private Singleton(){} public static Singleton getInstance() { if (instance == null){ synchronized (Singleton.class){ if (instance == null){ instance = new Singleton(); } } } return instance; } } public class Test { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException{ Singleton singleton1 = Singleton.getInstance(); Class classType = Singleton.class; Constructor constructor = classType.getDeclaredConstructor(null); constructor.setAccessible(true); Singleton singleton2 = (Singleton) constructor.newInstance(); System.out.println(singleton1 == singleton2); //false } } {% endcodeblock %} 输出结果是 {% codeblock 反射攻击结果 lang:java %} Singleton 私有构造方法被调用 1次 Singleton 私有构造方法被调用 2次 false {% endcodeblock %} 从结果可以看到，私有的构造函数被调用了两次，也就是说这样的单例模式并不安全。 为了防止单例模式被反射攻击，我们可以添加一个标志位，在新建对象时判断是否已经新建过对象了。 {% codeblock 防止反射攻击 lang:java %} public class Singleton { private static boolean flag = false; private static volatile Singleton instance = null; private Singleton(){ if (!flag){ flag = true; }else { throw new RuntimeException("构造函数被调用多次"); } } public static Singleton getInstance() { if (instance == null){ synchronized (Singleton.class){ if (instance == null){ instance = new Singleton(); } } } return instance; } } {% endcodeblock %} 当然这种方式也有一个缺点，那就是必须保证 Singleton.getInstance() 方法在反射之前调用，否则将不能正确获取单例对象。 而且,既然我们可以通过反射创建出对象，那么也可以通过反射修改标志位的值，这样一来，使用标志位的方法就不能完全防止反射攻击了。 序列化攻击接下来我们看一下序列化如何破坏单例模式，以恶汉模式为例。 {% codeblock 序列化攻击 lang:java %} public class Singleton implements Serializable{ private static final Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance() { return instance; } } public class Test { public static void main(String[] args) throws IOException,ClassNotFoundException{ Singleton singleton1 = Singleton.getInstance(); Singleton singleton2; FileOutputStream fos = new FileOutputStream("SerSingleton.obj"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(singleton1); oos.flush(); oos.close(); FileInputStream fis = new FileInputStream("SerSingleton.obj"); ObjectInputStream ois = new ObjectInputStream(fis); singleton2 = (Singleton)ois.readObject(); System.out.println(singleton1==singleton2); } } {% endcodeblock %} 输出结果为 false 表明我们的单例收到了攻击，那么如何防止这种情况呢？ 我们可以在被序列化的类中添加readResolve方法 {% codeblock 防止序列化攻击 lang:java %} public class Singleton implements Serializable{ private static final Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance() { return instance; } private Object readResolve(){ return instance; } } {% endcodeblock %} 说了这么多，不知道大家有没有这样一种感慨 「 都说单例模式是最简单的一种模式，这么还这么复杂，以后还让不让人活了 」。 那么有没有一种又简单有能防止所有攻击的方法呢？ 枚举枚举( enum )是 Java1.5 之后新加的特性。 大家一定很奇怪，为什么枚举可以实现单例呢？其实和 Java 的编译特性有关。因为枚举是 Java1.5 之后新加的，一般新加入的功能有一个很重要的问题需要解决，就是对以前代码的兼容性问题。而 Java 是通过 语法糖 的方式解决的。简单来说就是编写代码的时候可以使用新的关键字 enum 编写程序，但是 Java 编译器在编译成字节码的时候，还是会利用现有的技术编译成之前的 JVM 能够识别并正确运行的字节码，这就是语法糖技术。 我们先来看一下枚举编写的单例是什么样子的。 {% codeblock 枚举 lang:java %} public enum Singleton { INSTANCE; public static Singleton getInstance(){ return INSTANCE; } public void otherMethods(){ System.out.println("do something"); } } {% endcodeblock %} 这段代码看起来很简单，我们定义了一个枚举类型 INSTANCE, 这就是我们需要的单例。但是为什么这样就能实现线程安全的单例呢？要解决这个疑问，我们必须把这段代码进行反编译，看看 java 编译器究竟是如何编译这段代码的。 我们使用 java 自带的反编译工具 javap 就可以将这段代码反编译 javap -c Singleton 反编译结果如下： {% codeblock 反编译 lang:java %} public final class Singleton extends java.lang.Enum { public static final Singleton INSTANCE; public static Singleton[] values(); Code: 0: getstatic #1 // Field $VALUES:[LSingleton; 3: invokevirtual #2 // Method "[LSingleton;".clone:()Ljava/lang/Object; 6: checkcast #3 // class "[LSingleton;" 9: areturn public static Singleton valueOf(java.lang.String); Code: 0: ldc #4 // class Singleton 2: aload_0 3: invokestatic #5 // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum; 6: checkcast #4 // class Singleton 9: areturn public static Singleton getInstance(); Code: 0: getstatic #7 // Field INSTANCE:LSingleton; 3: areturn public void otherMethods(); Code: 0: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #9 // String do something 5: invokevirtual #10 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return static {}; Code: 0: new #4 // class Singleton 3: dup 4: ldc #11 // String INSTANCE 6: iconst_0 7: invokespecial #12 // Method "":(Ljava/lang/String;I)V 10: putstatic #7 // Field INSTANCE:LSingleton; 13: iconst_1 14: anewarray #4 // class Singleton 17: dup 18: iconst_0 19: getstatic #7 // Field INSTANCE:LSingleton; 22: aastore 23: putstatic #1 // Field $VALUES:[LSingleton; 26: return } {% endcodeblock %} 可能这段代码对于刚刚接触 java 的人来说一时可能看不懂，但是我们只要关注到一下几点就好了。 public final class Singleton extends java.lang.Enum&lt;Singleton&gt; 这说明枚举类型实际上被 java 编译器通过语法糖转换成了不可变类，继承自 Enum 类。 public static final Singleton INSTANCE,说明我们定义的枚举值 INSTANCE 实际上被 java 编译器转换成了不可变对象，只可以初始化一次。 关注到 INSTANCE 实际上是在 static {} 这段代码里初始化的。也就是说， INSTANCE 是在 Singleton 类加载的时候初始化的，所以一旦 Singleton 类加载了，INSTANCE 也就初始化了，不能再改变了，这就实现了单例模式。 然后如果我们尝试使用序列化或者反射的方式去攻击枚举单例，会发现都不能成功，这是由于 JVM 实现枚举的机制决定的。 最后，引用一下 《Effective Java》一书中的话。 单元素的枚举类型已经成为实现Singleton的最佳方法。 《Effective Java》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在阿里巴巴实习是什么体验]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%9C%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%AE%9E%E4%B9%A0%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[谨以此篇文章，纪念我的阿里实习之旅。 版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 第一篇 ● 入职2017年7月2号，我一个人，第一次做飞机，从广州到杭州，飞行两个小时，开始了我的阿里巴巴实习之旅。 刚下飞机的时候，准备去坐机场快车，遇到了一个和我一起拼车的哥们，目的地居然一样，都是XXX酒店（阿里对外地实习生提供两周免费酒店）。一问，果然和我一样都是阿里的实习生。更巧的是，到酒店前台办理入住的时候，前台妹子对我们说：「你们怎么不早说你们认识，不过还好，我正好把你们分在了同一个房间。」但是我们在机场才刚刚认识，突然觉得生活好奇妙。 7月3号，是第一天入职的时间。我所在的部门在滨江区，离我住的酒店3公里左右。早上，我们踩着单车去公司，终于看到了传说中的阿里巴巴。 从早上9点半一直到下午3点，我们都在新人培训中渡过。培训内容包括园区的工作生活指南、各种工具的使用、公司的规章制度等。到下午的时候，就和实习期间的师兄一起去IT管理中心领了电脑回部门了。阿里的正式员工开发的都是macbook和mac，我们实习生只有台式机。我领到的是一台I5 6500 + 256SSD + 8G RAM的联想台式机，对于做Android开发足够了。 我入职的当天是周一，而我的部门刚好有每周一下午开周会的习惯。所以我刚回到部门放下电脑，就和部门的人一起开周会去了。当时也是十分紧张，做自我介绍的时候不由自主地站了起来，被主管直接说不用站起来，坐着说就好了。 开完周会之后，已经差不多6点了，于是乎我又和部门的同事一起去吃了晚餐，第一天的实习生活什么事都没做就结束了。 第二篇 ● 培训我在阿里实习了一共两个月不到，一共参加了3次培训，除了入职第一天的新人培训之外，还有新生训练营和百年技术。 新生训练营是在入职两周左右举行的，培训时间一天，主要培训阿里的组织架构，各个BU的业务和主要产品，了解公司未来的发展方向等。由于新生训练营是在阿里巴巴西溪园区举行的，距离滨江园区很远。所以那天早上我们都要很早起床，去刚阿里的园区交驳车。 百年技术是在入职一个月左右举行的，培训时间三天，也是在西溪园区举行。这个培训之前是只有正式员工才有的，从今年起连实习生也必须参加了。培训分为几个专题，有持续发布，敏捷开发，算法，薪资福利等。每个专题都由相关领域的专家做分享,气氛也很好，有问题可以随时打断提问。 在百年技术的时候，有机会能见到公司的高管，像我参加百年技术的时候就见到了iDST的方广（华先胜）老师，他是北京大学博士，曾获选国际电气与电子工程协会院士(IEEE Fellow)、美国计算机协会ACM2015年度杰出科学家、MIT TR35大奖(全球35位35岁以下的杰出青年创新人物)等荣誉，也曾担任ACM Multimedia大会的程序委员会主席，是视觉识别和搜索领域的国际级权威学者。第一次见到这种级别的大牛，让我这种小透明激动了好久。 最近，阿里巴巴宣布获得机器视觉顶级会议ACM MM2020年主办权，华老师正是这次大会的主席！ 对于正式员工来说，还有百年阿里培训，这个培训主要是培养员工对阿里价值观的认同感的。顺带说一句，阿里的所有培训都是带薪的，也就是说培训的时候工资照拿，这点还是挺爽的。 第三篇 ● 工作我所在的部门是农村淘宝事业部，岗位是Android开发。实习第一周，师兄让我先熟悉代码，我就把部门的代码从gitlab上clone了下来。由于是第一次接触到商业级的代码，特别是淘宝这种有几亿用户量的代码，心里还是有点小激动的。 看了几天代码，给我的感觉就是： 阿里大多数都是用自己造的轮子，很少用别人的轮子。 模块化特征很明显、经常是需要用某个功能的时候几行代码就搞定了。 由于多人协作和敏捷开发的原因，代码里存在一定程度的重复。 体量巨大，模块都是几百个以上的，由不同小组开发，再统一集成起来。 重头戏应该是入职两周的时候，刚好需求评审通过，我们需要进行版本迭代，师兄带着我参与了进来。于是，我从找bug开始，到小功能的添加，再到和服务端的联调，再到灰度测试，最后到版本发布，一系列的流程都参与了进来。这里应该特别感谢一下我的师兄，因为我在整个实习过程中经常去问他，他每次都非常有耐心的和我讲，甚至还怕我的显示器太小主动把他的大显示器给了我，让我成为了全部实习生里面唯一有两个显示器的人。 从此我可以说，手机淘宝的app里面有我的代码啦！ 实习快结束的时候，所有的实习生有一个实习答辩。就是做一个PPT，展示你实习期间做了什么。我记得我的PPT一共改了7、8遍。中间还有一次内部预答辩，部们的主管和师兄们会给你提意见，好让你进一步修改。 答辩结束后，我的实习生涯也差不多告一段落了。 第四篇 ● 吃喝玩乐关于吃的，阿里巴巴滨江园区有两层食堂，种类还是挺丰富的。有自选餐、各种套餐、减肥餐、特色小吃等等。公司午餐和晚餐各补贴13元，晚上9点后还有10元的夜宵补贴，基本上相当于吃饭免费了，这对于一个实习生来说也算一笔不小的福利了。从我第一天来开始就给自己定下了个目标，「实习结束前把食堂所有菜式都吃上一遍」，最后走之前回顾了一下，应该算完成目标了把。 我所在的团队有14个人，大家平常关系很好，经常一起开黑王者荣耀，开开玩笑什么的。我实习期间部门一起出去聚餐了两次，一次是晋升的同学请客，一次是周年庆的同学请客。我实习期间他们还分批去了千岛湖，泰国，日本等地方旅游，可惜来得太晚了，不然还可以混次旅游。 我来的第二周就碰上了淘宝造物节。作为部门福利，老大给了我一张票，所以我又去造物节上逛了一圈，看到了沈梦辰、赵雪峰等明星，还有淘咖啡无人售货店。 由于公司每周有往返上海的免费班车，所以答辩结束后我又去了趟上海逛了一圈。不得不说，清晨的上海外滩还是挺漂亮的。 第五篇 ● 总结实习已经结束了，回顾我在阿里巴巴的实习经历，虽然时间不长，但是给予我的收获却是巨大的。这种收获，既包括了物质上的，也包括了精神上的。关于这次实习，我的体会主要有一下几点： 其实我知道自己并没有优秀到轻而易举的进入阿里巴巴实习的。我获得这个机会多多少少有运气的成分。但是这次经历却给了我信心和勇气，相信只要努力，一切都有可能。 我必须要感谢我在我的实习期间帮助过我的同事和师兄们。正是他们不厌其烦的给我解答我的困惑和善意主动地指出我的缺点，才让我的实习不至于走了很多弯路，让我了解了许多职场应该注意的地方。 阿里巴巴是一家非常优秀的公司。虽然它目前还存在一些缺点，比如审批流程繁琐，会议比较多等。但是阿里愿意给年轻人提供许多的机会，让我们能够靠努力成为自己想成为的人。]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>阿里巴巴</tag>
        <tag>实习</tag>
        <tag>杭州</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android校招面试总结]]></title>
    <url>%2F2017%2F11%2F14%2FAndroid%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[版权声明：本文为 冬夏 原创文章，可以随意转载，但请注明出处。 谨以此篇文章，纪念我的漫漫求职路。 掐指一算，从今年3月份开始复习准备实习生招聘，到10月底秋招正式结束，经历了半年的坎坷求职路。还好，结果还算满意，也想把这段时间的面试经验、总结和个人的一些看法分享给大家，希望大家都能找到满意的工作。 截至到目前为止，投过简历的公司有：阿里巴巴，腾讯，百度，网易，网易游戏，华为，美团，CVTE，4399 面试过的公司有：阿里巴巴，腾讯，网易游戏，华为，美团，4399 拿到offer的公司有：阿里巴巴，网易游戏，美团，4399 文章主要内容 面试过程中遇到的问题及简要答案 每次面试后的总结 校招总结及建议 面试过程中遇到的问题及简要答案Java相关 Q1：Java内存模型（4399） A1：堆、栈、方法区，程序计数器 Q2：Java如何实现垃圾回收（4399、阿里巴巴） A2：典型的垃圾回收算法包括 Mark-Sweep（标记-清除）算法优点：效率高，实现简单缺点：产生内存碎片 Copying（复制）算法优点：实现简单、不容易产生内存碎片缺点：可使用内容变为原来一半 Mark-Compact（标记-整理）算法优点：不容易产生内存碎片缺点：，复杂、耗时 Generational Collection（分代收集）算法JVM根据对象存活时间将内存划分为永久代，老年代，新生代。 新生代垃圾回收算法：Copying（复制）算法 老年代垃圾回收算法：Mark-Compact（标记-整理）算法 永久代：垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(注: Java8中已经移除了永久代，新加了一个叫做元数据区(meta data)的native内存区) Q3：Java发生垃圾回收时程序会怎么样（阿里巴巴) A3：stop the world Q4：Java线程同步的几种方式（网易游戏）A4： 同步方法 同步代码块 wait与notify volatile 重入锁 ThreadLocal 阻塞队列 Q5：一行代码从写完到执行过程中经历了什么？（阿里巴巴） A5：编译-加载-校验-准备-解析-使用-卸载 Q6：HashMap 和 HashTable的区别（阿里巴巴）A6： HashMap非线程安全、HashTable线程安全 支持key和value为null 不支持支持key和value为null HashMap在JDK1.8之后当链表长度大于8时自动转为红黑树，小于6转回来（设定两个阈值是为了不频繁发生转换） Q7：Concurrenthashmap和Hashtable的区别（网易游戏）A7：效率高：Concurrenthashmap锁的粒度（一个桶）比Hashtable（整个结构）小 Q8：创建线程的方法（阿里巴巴） A8： 继承Thread类 实现Runnable接口 应用程序可以使用Executor框架来创建线程池 Q9：线程池的种类及区别（网易游戏）A9： Executors.newFixedThreadPool(nThreads)：可重用的，固定线程数的线程池 Executors.newCachedThreadPool()：根据需要创建线程 Executors.newSingleThreadExecutor()：单个线程的线程池，特点：如果线程执行过程中被kill，会重新生成一个线程 Executors.newScheduledThreadPool(corePoolSize)：可以调度的线程池，可以在指定延迟之后执行 Q10：Java异常（4399）A10：Java的两种异常：checked异常和runtime异常，区别 checked异常：调用方法需捕获，定义方法需声明 runtime异常：调用方法不需捕获，定义方法不需声明 Q11：Java里引用的类型和区别（阿里巴巴） A11： 强引用（Strong References）强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。(注：强引用其实也就是我们平时A a = new A()这个意思) 软引用（SoftReference）用来实现一些内存敏感的缓存(Soft references are for implementing memory-sensitive caches)，只要内存空间足够，对象就会保持不被回收。反之，当宿主进程的内存空间不足时，对象就会被GC回收。所以SoftReference意味着：hold on until you can’t. 弱引用（WeakReference）可以用来实现一些规范化映射（WeakHashMap），其中key或者value当它们不再被引用时可以自动被回收。当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。这个引用不会在对象的垃圾回收判断中产生任何附加的影响。 虚引用（PlantomReference）与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 Q12：Java类加载机制（阿里巴巴） A12： 父类委托（双亲委托）：先由父类加载器尝试加载该类，加载不成功时才尝试从自己的类路径中加载 缓存机制：加载过的类存放在方法区，这就是为什么修改了class，必须重启JVM才生效的原因 Q13：==、equals、hashcode的区别与联系（4399） A13： ==表示两个变量指向同一个对象 覆盖equals一定要覆盖hashcode 两个equals相等的对象hashcode一定相等，反之不然 Q14：为什么String要设计成不可变类（腾讯） A14： 字符串常量池的需要 允许String对象缓存HashCode 安全性 Android相关 Q1：Android内存泄露情况分析（网易游戏） A1： 单例造成的内存泄漏 非静态内部类创建静态实例造成的内存泄漏（非静态内部类默认会持有外部类的引用） Handler造成的内存泄漏（Handler的生命周期和Activity不同造成的）Handler发送的Message尚未被处理,则MessageQueue持有Handler的引用(post方法)。而Handler又持有Activity的引用 匿名内部类和线程造成的内存泄漏（匿名内部类持有外部类的引用,如果这时候将匿名内部类的引用传入一个异步线程，则有可能造成内存泄漏） 资源未关闭造成的内存泄漏 Q2：Android启动流程（腾讯） A2： Q3：Android动画的种类（美团） A3：逐帧动画、补间动画、属性动画 Q4：ListView的优化（网易游戏，美团） A4： 判断converView是否为空 使用ViewHolder保存View的各个Widget引用。避免每次都重新findViewbyId Q5：View的绘制机制（腾讯） A5：onMeasure()、onLayout()、onDraw()（这个问题很经典也很复杂，建议仔细研究） Q6：Android的序列化方式（美团） A6：Serializable、Parcelable Q7：Activity的四种启动模式及其区别（阿里巴巴） A7： standard：默认模式，在这个模式下，都会创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。 singleTop：可以有多个实例，但是不允许多个相同Activity叠加。即，如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法。 singleTask：只有一个实例。在同一个应用程序中启动它的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。 singleInstance：只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。 Q8： Android从按下图标到应用启动的过程（腾讯） A8：用户在Launcher程序里点击应用图标时，会通知ActivityManagerService启动应用的默认Activity，ActivityManagerService发现这个应用还未启动，则会通知Zygote进程孵化出应用进程，然后在这个dalvik应用进程里执行ActivityThread的main方法。应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService（绑定）保存应用进程的一个代理对象(applicationthread)，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，并执行它的生命周期方法。 Q9：如何保证service在后台不被杀死(网易游戏) A9： 设置1像素Avticity，监听锁屏广播，服务在另外进程减少主进程使用内存（5.0以后会一起杀死进程组，所以不适合） 设置前台服务，startForeground（降低kill概率） 粘性服务，在onStartCommand中设置成START_STICKY，kill之后会重启 捆绑系统服务 双进程Service相互守护 账号同步唤醒APP 全家桶相互唤醒 JobSheduler native进程方式 设置高优先级（貌似无效） 应用拆分 Q10：为什么一定要在UI线程更新视图（阿里巴巴、腾讯） A10：在移动设备中，UI的使用是绝对设备对于用户体验的重要因素之一。而Android系统当中的控件都不是线程安全的，这导致当使用多线程模式的时候在多个线程共同使用同一个UI控件时容易发生不可控的错误，而这是致命的。不过这里提一点的就是，在Activity的onResume执行之前，是可以在子线程里更新UI的，具体原因这里就不细讲了，有兴趣的可以自己去查。 Q11：Android进程间通信方式（美团） A11： AIDL Broadcast ContentProvider Binder Intent Socket Q12：IntentFilter和Intent的匹配规则（美团） A12：Intent包括显式Intent和隐式Intent，显示Intent通过直接指定类名进行匹配。隐式Intent则与IntentFilter中的action、category、data进行匹配。 action匹配规则 一个intent-filter中可以有多个action intent中的action与intent-filter中有一个相同即可 action区分大小写 category匹配规则 Intent中可以不存在category，但如果存在就必须匹配intent-filter其中一个 系统在startActivity或者startActivityForResult的时候默认为Intent加上一个android.intent.category.DEAFAULT，所以必须在intent-filter中加上android.intent.category.DEFAULT这个category data匹配规则 data由两部分组成，mimeType和URI。 URI格式：://:[||] //示例content://com.example.project:200/folder/subfolder/etc URI的scheme的默认值为content和file minType指数据类型 匹配规则与action类似，只要有一个data匹配就可以 Q13：Android常用布局，Activity生命周期（腾讯） A13： 常用布局： RelativeLayout FrameLayout LinearLayout AbsoluteLayout GridLayout TableLayout 生命周期： Q14：Activity弹出Dialog会触发什么生命周期方法（腾讯） A14：如果是当前Activity弹出的dialog则不会执行Activity任何生命周期中的方法,只有其它Activity弹出了Dialog或者拦住了当前的Activity才会执行onPause() Q15：Handle、Looper、MessageQueue之间的关系（网易游戏、阿里巴巴） A15： Handler： 目的：线程间信息传递，比如非UI线程可以通过Handler发送信息到UI线程从而修改界面。 Handler在创建的时候绑定到创建它的线程和线程的消息队列MessageQueue 主要有两种使用方法： 通过post或者postAtTime发送Runable对象 通过sendMessage，sendMessageAtTime，sendMessageDelayed发送消息对象（Message），然后在Handler所在线程的handleMessage中处理（需要自己实现Handler的子类或者实现callback接口）。 当程序运行时，进程为主线程分配一个消息队列MessageQueue，负责处理activities，broadcast，receivers等对象和它们创建的窗口，你可以新建自己的线程，然后通过Hanlder和主线程进行交流。 Looper：每个线程只有一个Looper，不停地从MessageQueue中取消息出来处理，创建Looper对象的时候回创建MessageQueue对象（主线程系统为其创建了Looper，自己创建的线程必须调用Looper.prepare()创建Looper对象） MessageQueue：先进先出消息队列 计算机基础 Q1：死锁的条件和避免方法（网易游戏） A1： 互斥：一个资源每次只能一个线程使用 请求与保持：一个线程因请求资源而阻塞时，对已获得的资源保持不放 不可剥夺：线程已获得的资源，在未使用完之前，不可强行剥夺 循环等待：若干线程之间形成一种收尾相接的循环等待资源关系 防止死锁的手段 静态分配资源（破坏 请求与保持） 层次分配（破坏 循环等待） 死锁避免 避免线程永久地占有系统资源 防止进程在处于等待的情况下占用资源 Q2：线程和进程的区别（网易游戏） A2： 进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动 进程是操作系统进行资源分配和调度的一个独立单位 Q3：Http/Https原理分析以及Https如何保证安全（网易游戏，腾讯） A3：Https = Http + SSL，其实就是证书验证，公钥加密，私钥解密的整个流程，建议自己理解一下，常问 Q4：TCP为什么有四次挥手，但是只有三次握手（腾讯） A4：因为SYN和ACK和并在一起了 Q5：TCP和IP的报文格式 A5： IP报文格式： TCP报文格式： 设计模式 Q1：常用的设计模式有哪些（美团） A1：策略模式、观察者模式、装饰着模式、工厂模式、单例模式、外观模式、设配器模式、组合模式、状态模式，生成器模式等 Q2：单例模式怎么保证线程安全（网易游戏） A2：恶汉模式、懒汉模式、双重检查锁机制、静态内置类、枚举类型 Q3：MVP、MVC、MVVM的区别和联系（美团） A3： MVC： MVP： MVVM： 算法 Q1：如何求一个数的平方根（网易游戏） A1：牛顿法、平方根倒数速算法、平方根倒数速算法 Q2：判断一个整数链表是否存在环路（阿里巴巴） A2：快慢指针 Q3：大数乘法（腾讯） A3：模拟手工计算法，分治算法、FFT算法 Q4: 各种排序算法的比较（腾讯） A4： 稳定排序 不稳定的排序 其他 Q1：自我介绍 A1：建议时长1-3分钟，介绍内容包括姓名、学校、专业、研究方向、对应聘岗位所需技能的熟悉程度、为什么要应聘这个岗位、相关项目等，兴趣爱好一般不介绍，介绍的时候要和面试管有互动。 Q2：你觉得你比别人优秀的一点是什么？ A2：选一个自己性格上的特点，不要选特长，而且要有例子说明你的这个优点对工作是有帮助的。比如应聘Android开发时说自己对技术很敏感，经常关注技术动态，并且对技术有自己的理解。 Q3：你的缺点 A3：建议选一个从一方面看是缺点，但是从另外一方面看又是优点的特点。比如说自己很纠结细节，因此浪费了不少时间，但是从另一方面看又表现了自己很认真仔细。 Q4：印象最深刻的一件事 A4：可以说和技术有关的或者和技术无关的，但是要体现出为什么这件事让你的印象那么深，比如让你明白了什么道理等。 Q5：还有什么问题问我 A5：这个问题一般都是最后一个问题，一般可以问职业上的困惑，比如对前景的看法、对某向新技术的看法、咨询岗位工作内容、或者问自身的不足、之前回答不上的问题的思路等，要让面试官觉得你很重视这份工作，同时体现出自己很好学、上进。 每次面试后的总结春招 网易游戏内推 一面挂 面试总结：网易游戏是实习里面面得最早的，当时准备得并不好，所以挂了也很正常，出网易大厦的时候也没有觉得不开心，只想着抓紧复习准备其他的面试。 华为 录用池挂 面试总结：华为的面试是面试过的所有公司里面最看不透的。面试基本不问基础知识，问项目也都是自己在说，没有追问细节，总体来说就是缺少互动。面试通过率高得吓人，基本都是刷学校的。还好我是个例外，不然也不会有后面的故事了，感谢华为不录之恩。 腾讯内推 三面挂 面试总结：一面是电话面试，二面和三面是在腾讯总部面的。总体上来说表现得并不好，感觉腾讯非常注重底层原理和计算机网络，不是那种知道就行，还要知道为什么，这些没有长时间的积累和实际项目锻炼很难获取的知识。 阿里内推 四面挂 面试总结：全程电话面试，一面，三面，四面都面得还可以，就是最重要的二面面得不好。阿里巴巴非常注重对技术的理解，比如一个问题除了用一种方法解决还能用什么方法解决，还有就是如果笔试的题当时不会做，过后有没有再去思考。 腾讯校招 一面挂 面试总结：虽然是一面就挂了，但是面试官和我聊得还行，只是他问我如果让我做游戏我会怎么看，因为我觉得做游戏需要那种算法很厉害的人，当时我回答他说可能我的能力不够，所以就跪了。 4399 三面offer 面试总结：面试4399的时候，是我找实习最低落的时光。周围的人基本都找到实习了，只有我没有，很虚。虽然最后没有去4399，但是还是很感谢4399的面试官给了我肯定。 阿里校招 三面offer 面试总结：阿里的内推不通过就自动转校招了。当时我宿舍没有网络，所以三次视频面试都是在实验室面的。整个实验室的小伙伴包括导师都静静地听我和面试官吹水。面试阿里我觉得有两次让面试官眼前一亮的，一次是二面面试官问函数原理的时候我说出来了，让他惊讶了一下。还有一次是HR问我缺点的时候，我的回答让她表示了赞同。 秋招 网易游戏 四面offer 面试总结：网易游戏的招聘的时候指定了特定学校才能投简历，这样就限制了很多人了。虽然我是这个规定的受益者，但是我并不觉得这个规定好。面试的时候感觉网易游戏非常注重算法和基础。但是我的算法并不好，能拿到offer可能是因为我有了阿里的offer和有一些看法和面试官不谋而合把。 百度 放弃面试 面试总结：百度的面试通知来得非常晚，当时我已经拿了阿里和网易游戏的offer了，再加上百度的岗位在北京，所以就放弃了。 腾讯内推 一面挂 面试总结：接到腾讯的电话的时候我刚刚做上从杭州回广州的飞机，所以只能另外约时间。是微信部门打电话过来的，问了我阿里的项目，应用架构，开发遇到的问题，动态化框架的理解等。微信部门的要求很高，我也觉得我并没有达到他们的要求，不过还是感谢面试官。 美团内推 四面offer 面试总结：美团是通过同学内推的，一面是电话面试，二面、三面是视频面试，四面是电话面试。感觉美团很注重实战能力，二面的时候直接就给我一张截图让我分析布局。感觉美团在技术上的积累还是不错的，个人也看好美团的发展前景，只是因为岗位在上海，最终还是拒了。 腾讯校招 一面挂 面试总结：第四次面腾讯，我已经不抱希望了，果然，一面就挂了。不过还是感谢面试官给我指出了面试过程中的问题，不要带很多的语气词。 校招总结及建议 就我了解的情况来说，今年周围同学就业情况并不太乐观。虽然人工智能大火导致了相应的岗位需求量大增，而且工资开得都比较高，40w+的也经常听到。但是与人工智能有关的机器学习，深度学习，数据挖掘等岗位大多只招聘硕士和博士，而且每个公司招聘的数量并没有开发的人数多，而且有加速饱和的趋势。 如果你现在还没有选择方向，那么在选择人工智能之前要先考虑好以下几点 自己是真的喜欢和适合这个方向还是只是冲着高薪去的。如果你不是真的感兴趣，可能最后会很痛苦。 自己的数学水平，特别是概率论和矩阵分析水平怎么样。如果理论知识不够最后很可能会沦为调参工程师，只是重复地做着别人的实验。 不像做开发的门槛比较低，机器学习的从业人员大多具有比较高的学历和名校背景做背书，在这样的情况下要脱颖而出会比较困难，这点应该做好准备。 关于移动开发，现在的岗位需求量已经很小了，而且和前端的融合趋势已经很明显了。如果你没有基础，现在已经不建议学习移动开发了，性价比太低。当然，高端人才还是稀缺的，不管是对某个领域有比较深造诣的人才还是全栈人才。 关于后台，需求一直比较大，也比较稳定，技术更新换代对比移动端和前端也比较慢，如果你有兴趣，可以往后台发展。 最后，再次希望大家都能找到满意的工作！]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>校招</tag>
        <tag>面试</tag>
        <tag>BAT</tag>
      </tags>
  </entry>
</search>
