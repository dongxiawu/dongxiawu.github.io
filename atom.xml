<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Android 从入门到精通</title>
  
  <subtitle>冬夏的个人小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongxiawu.github.io/"/>
  <updated>2018-06-07T12:05:40.219Z</updated>
  <id>https://dongxiawu.github.io/</id>
  
  <author>
    <name>冬夏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机启动流程</title>
    <link href="https://dongxiawu.github.io/2018/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://dongxiawu.github.io/2018/05/21/计算机启动流程/</id>
    <published>2018-05-21T04:45:51.000Z</published>
    <updated>2018-06-07T12:05:40.219Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/05/21/计算机启动流程/计算机启动流程.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>你有没有想过，计算机是怎么启动的呢？从按下电源开始，到操作系统开始运行，计算机的工作流程是怎么样的呢？</p><p>计算器的启动流程大致如图所示。<br><img src="/2018/05/21/计算机启动流程/计算机启动流程.png"></p><h1 id="启动自检"><a href="#启动自检" class="headerlink" title="启动自检"></a>启动自检</h1><p>按下计算机的开机键后，电源首先给主板供电，此时电压不稳定，主板上的芯片组（如南北桥等）会向CPU发出并保持一个Reset信号。当电压稳定后，芯片组便撤去Reset信号，CPU开始运行，如果此时出了问题（比如CPU坏了或根本没装），那么主板上除了风扇在转之外没有任何动静。一些主板会在CPU故障或缺失时发出峰鸣提示。</p><p>如果一切正常，CPU就开始运行了。在一个多处理器或多核处理器的系统中，会有一个CPU被动态的指派为引导处理器（bootstrap processor，BSP），用于执行全部的BIOS和内核初始化代码。其余的处理器，此时被称为应用处理器（application processor，AP），一直保持停机状态直到内核明确激活他们为止。</p><p>虽然目前的CPU基本都是32位或64位的，但CPU上电时的地址线只有20位，也就是说只有1MB的内存可以寻址，这种状态叫做“实模式”，这么做主要是为了向前兼容。此时的代码可以读写物理地址、分页功能无效、没有保护和特权级的概念。</p><p>CPU上电后，大部分寄存器均复位到定义好的初始值，其中包括指令指针寄存器（EIP），它记录了下一条即将被CPU执行的指令所在的内存地址。现代32位Intel CPU的标准定义CPU复位后第一条指令的地址为0xFFFFFFF0（长16字节，在4GB内存空间的尾部，远高于1MB），虽然此时的CPU还只能寻址1MB的内存，但凭借一个奇特的技巧，一个隐藏的基地址（其实就是个偏移量）会与EIP相加，其结果指向第一条将被执行的指令所处的地址。这个特殊的地址叫做复位向量(reset vector)。</p><p>主板保证在复位向量处的指令是一个跳转，而且是跳转到BIOS（Basic Input/Output System）执行入口点所在的内存映射地址。由于芯片组提供了内存映射功能，此时的内存地址存放着CPU初始化所需的真正内容。这些内容全部是从包含有BIOS的闪存映射过来的。下面的图例列出了相关的内存区域：</p><img src="/2018/05/21/计算机启动流程/引导时内存映射.png"><p>随后，CPU开始执行BIOS的代码，首先初始化机器中的一些硬件。之后BIOS开始执行上电自检过程（Power On Self Test，POST），检测计算机中的各种组件（如显卡，内存，键盘等）。如果检测不到一个可用的显卡，POST就会失败，导致BIOS进入停机状态并发出鸣音提示（因为此时无法在屏幕上输出提示信息）；如果检测不到键盘，会导致停机，屏幕上显示出错信息。其实POST既是检测又是初始化，还要枚举出所有PCI设备的资源——中断，内存范围，I/O端口。现代的BIOS会遵循高级配置与电源接口（ACPI）协议，创建一些用于描述设备的数据表，这些表格将来会被操作系统内核用到。</p><h1 id="主引导记录"><a href="#主引导记录" class="headerlink" title="主引导记录"></a>主引导记录</h1><p>主引导记录（MBR，Master Boot Record）是一段长度为512字节的，用于指示操作系统所在位置以及装载操作系统的表，位于存储设备的第一个扇区，其组成结构如图所示。</p><img src="/2018/05/21/计算机启动流程/MBR结构.jpg"><p>其中，主引导记录最开头是第一阶段 <em>引导代码</em>。其主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（如GNU GRUB）。它不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现多系统引导。</p><p><em>硬盘分区表</em> 占据主引导扇区的64个字节（偏移01BEH–偏移01FDH），可以对四个分区的信息进行描述，其中每个分区的信息占据16个字节。分区表是标准化的，与操作系统无关。具体每个字节的定义可以参见硬盘分区结构信息。</p><p>从主引导记录的结构可以知道，它仅仅包含一个64个字节的硬盘分区表。由于每个分区信息需要16个字节，所以对于采用MBR型分区结构的硬盘，最多只能识别4个主要分区（Primary partition）。所以对于一个采用此种分区结构的硬盘来说，想要得到4个以上的主要分区是不可能的。这里就需要引出扩展分区了。扩展分区也是主要分区的一种，但它与主分区的不同在于理论上可以划分为无数个逻辑分区。</p><p>扩展分区中逻辑驱动器的引导记录是链式的。每一个逻辑分区都有一个和MBR结构类似的扩展引导记录（EBR），其分区表的第一项指向该逻辑分区本身的引导扇区，第二项指向下一个逻辑驱动器的EBR，分区表第三、第四项没有用到。</p><p><em>结束标志字</em> 55，AA（偏移1FEH－偏移1FFH）最后两个字节，是检验主引导记录是否有效的标志。</p><h1 id="引导系统"><a href="#引导系统" class="headerlink" title="引导系统"></a>引导系统</h1><p>POST完毕后，BIOS就准备引导操作系统了，它首先依次（可定制）将每一个存储设备（硬盘，光驱，软盘等）的第一个扇区（前512字节）读入地址为0x7C00的内存区域，并判断0x7DFE-0x7DFF（MBR的结束标志位）是否为0x55 0xAA，若不是，则尝试下一个存储设备。如果找不到合适的引导设备，BIOS会显示出错信息并停机，若找到合适的引导设备，则BIOS将CPU控制权交给MBR，而不管MBR里的代码是什么。</p><p>接下来，MBR中的引导代码将找到操作系统所在的位置并对操作系统进行引导。针对操作的数量，分为以下两种情况：</p><ol><li><p>只有一个操作系统，则依次检查每一个主分区和扩展分区，判断哪个分区表是激活的（分区表第一个字节为0x80），加载那个分区的引导扇区（该分区的第一个扇区），引导扇区的作用是指出操作系统在该扇区的哪个位置，接着就会加载操作系统。</p></li><li><p>存在多个操作系统，则不加载引导扇区，而是直接加载事先安装好的启动管理器（boot loader），由用户选择启动哪一个操作系统（如Grub等）。</p></li></ol><p>接着，操作系统的内核首先被载入内存并开始运行、初始化，操作系统也随着启动。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机启动时一个软件和硬件相关的工程。</p><p>首先，CPU上电后从一个固定的地址开始取指令，这就要求主板上必须保证在该地址能够顺利到达BIOS。</p><p>接着，BIOS进行上电自检，为什么BIOS能够检查出有没有显卡，内存，鼠标等呢？一方面，主板的布线决定了每个设备的位置和地址空间；另一方面，不同品牌的硬件设备都遵循相同的通信协议，所以BIOS能够正确检测出设备。</p><p>接着，MBR定义了硬盘的分区大小、格式、引导方法以及操作系统所在位置，只有按照对应的格式和规定正确存放数据，操作系统才能最终正确启动。</p><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>随着硬件的不断发展，BIOS+MBR的启动方式的缺陷也越来越显现出来，比如：BIOS启动界面只能使用键盘，而不能使用鼠标，并且通常是命令行界面，并不美观。另外，有MBR的分区表结构可以看到，每个分区表最大容量为2TB。</p><p>近年来，出现了UEFI+GPT的启动方式</p><p>其中，UEFI（Unified Extensible Firmware Interface）为统一可扩展固件接口，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。可扩展固件接口负责加电自检（POST）、联系操作系统以及提供连接操作系统与硬件的接口。</p><img src="/2018/05/21/计算机启动流程/UEFI与BIOS对比.jpg"><p>由BIOS与UEFI的启动对比图可以发现，由于略过了启动时自检的过程，所以电脑开机启动速度会快不少。</p><p>GPT（GUID Partition Table）为全局唯一标识分区表，是可扩展固件接口（EFI）标准的一部分，被用于替代BIOS系统中的主引导记录（MBR）分区表。GPT磁盘分区样式支持最大为128个分区，一个分区最大18 EB（Exabytes）。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/05/21/计算机启动流程/计算机启动流程.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Common" scheme="https://dongxiawu.github.io/categories/Common/"/>
    
    
      <category term="计算机" scheme="https://dongxiawu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java枚举类型原理</title>
    <link href="https://dongxiawu.github.io/2018/05/16/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%8E%9F%E7%90%86/"/>
    <id>https://dongxiawu.github.io/2018/05/16/Java枚举类型原理/</id>
    <published>2018-05-16T08:40:01.000Z</published>
    <updated>2018-05-17T14:12:05.694Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/05/16/Java枚举类型原理/Java枚举.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><a id="more"></a><p>枚举（Enum）类型是 java 5 中新增的一种数据类型，它能够帮助我们更加快捷和安全的实现枚举。</p><p>回想之前我们在定义枚举常量时的做法：</p><pre><code>public static final int MONDAY =1;public static final int TUESDAY=2;public static final int WEDNESDAY=3;public static final int THURSDAY=4;public static final int FRIDAY=5;public static final int SATURDAY=6;public static final int SUNDAY=7;</code></pre><p>这样的定义方式虽然也能正常工作，但却存在许多不足，比如不小心把 MONDAY 和 TUESDAY 都置为 2 时，编译器并不会报错，但是却很难进行排查。</p><p>在 Java 5 之后，我们可以用如下的定义定义枚举类型。</p><pre><code>public enum Day {    MONDAY, TUESDAY, WEDNESDAY,    THURSDAY, FRIDAY, SATURDAY, SUNDAY;}</code></pre><p>并可以在程序中通过 <code>Day.MONDAY</code> 的方式使用，这无疑大大提高了程序的安全性。</p><p>我们知道，编程语言的设计具有前向兼容性，这意味着后续的语言特性实际上都是通过语法糖来实现的，那么枚举类型的内部实现原理是怎么样的呢？我们通过将上面的枚举类 Day 通过 <code>javap</code> 命令进行反编译，再将反编译的代码通过改写使其更加容易阅读，最终得到下面的反编译代码。</p><pre><code>public final class Day extends Enum&lt;Day&gt;{    //编译器为我们添加的静态的values()方法    public static Day[] values()    {        return (Day[])$VALUES.clone();    }    //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法    public static Day valueOf(String s)    {        return (Day)Enum.valueOf(Day, s);    }    //私有构造函数    private Day(String s, int i)    {        super(s, i);    }     //前面定义的7种枚举实例    public static final Day MONDAY;    public static final Day TUESDAY;    public static final Day WEDNESDAY;    public static final Day THURSDAY;    public static final Day FRIDAY;    public static final Day SATURDAY;    public static final Day SUNDAY;    private static final Day $VALUES[];    static    {            //实例化枚举实例        MONDAY = new Day(&quot;MONDAY&quot;, 0);        TUESDAY = new Day(&quot;TUESDAY&quot;, 1);        WEDNESDAY = new Day(&quot;WEDNESDAY&quot;, 2);        THURSDAY = new Day(&quot;THURSDAY&quot;, 3);        FRIDAY = new Day(&quot;FRIDAY&quot;, 4);        SATURDAY = new Day(&quot;SATURDAY&quot;, 5);        SUNDAY = new Day(&quot;SUNDAY&quot;, 6);        $VALUES = new Day[] {            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY        };    }}</code></pre><p>通过阅读上面的反编译后代码，我们可以对枚举类型的实现进行总结：</p><ol><li>枚举类型是通过继承 Enum 类来实现的，并且最终生成 final 类来强化不可变性。</li><li>枚举类型的构造函数为私有的，具有 String 和 int 两个参数，分别代表枚举的名称和序号，序号按照定义的顺序从小到大排列。</li><li>每一个枚举都代表一个枚举类事例，并且为 static 和 final，在枚举类的静态代码块中进行初始化，并且有一个 $VALUES 数组保存所有的枚举。</li><li>通过 valueOf 方法可以完成枚举名称到枚举对象的查找。</li><li>values()方法返回的是 $VALUES 数组的克隆对象，这能防止$VALUES 数组被篡改。</li></ol><p>接下来，我们来分析一下自定义枚举类型所继承的 Enum 类</p><pre><code>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;        implements Comparable&lt;E&gt;, Serializable {    private final String name;    public final String name() {        return name;    }    private final int ordinal;    public final int ordinal() {        return ordinal;    }    protected Enum(String name, int ordinal) {        this.name = name;        this.ordinal = ordinal;    }    public String toString() {        return name;    }    public final boolean equals(Object other) {        return this==other;    }    public final int hashCode() {        return super.hashCode();    }    protected final Object clone() throws CloneNotSupportedException {        throw new CloneNotSupportedException();    }    public final int compareTo(E o) {        Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;        Enum&lt;E&gt; self = this;        if (self.getClass() != other.getClass() &amp;&amp;            self.getDeclaringClass() != other.getDeclaringClass())            throw new ClassCastException();        return self.ordinal - other.ordinal;    }    @SuppressWarnings(&quot;unchecked&quot;)    public final Class&lt;E&gt; getDeclaringClass() {        Class&lt;?&gt; clazz = getClass();        Class&lt;?&gt; zuper = clazz.getSuperclass();        return (zuper == Enum.class) ? (Class&lt;E&gt;)clazz : (Class&lt;E&gt;)zuper;    }    public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) {        T result = enumType.enumConstantDirectory().get(name);        if (result != null)            return result;        if (name == null)            throw new NullPointerException(&quot;Name is null&quot;);        throw new IllegalArgumentException(            &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);    }    protected final void finalize() { }    private void readObject(ObjectInputStream in) throws IOException,        ClassNotFoundException {        throw new InvalidObjectException(&quot;can&apos;t deserialize enum&quot;);    }    private void readObjectNoData() throws ObjectStreamException {        throw new InvalidObjectException(&quot;can&apos;t deserialize enum&quot;);    }}</code></pre><p>通过阅读上面的 Enum 抽象类，我们可以对其特点进行总结：</p><ol><li>由 equals 方法可知每个枚举只与自身相等，没有等效相等的枚举。</li><li>由 clone 方法可知枚举对象不允许克隆，这能保证每一个枚举都是唯一的。</li><li>由 compareTo 方法可知枚举只能与同类型的枚举相比较，返回结果为枚举的顺序之差。</li><li>由 finalize 方法可知枚举类不允许实现 finalize 方法，这与枚举的安全性有关。</li><li>由 readObject 方法和 readObjectNoData 方法可知枚举对象不允许反序列化，这也能保证每一个枚举都是唯一的。</li></ol><p>由以上的分析我们可以发现，枚举的最大特点就是唯一性，同时可以发现只有单个元素的枚举在不经意间符合了单例模式的要求，具体为：</p><ol><li>枚举类为不可变类，这防止了单例类被继承。</li><li>枚举类型的构造函数为私有的，因此不能主动创建对应的单例对象。</li><li>枚举的元素为 public static final 类型，并且在类加载的时候在静态代码块内完成了初始化，这相当于单例模式的恶汉模式。</li><li>枚举类对象不允许克隆，这能保证每一个单例都是唯一的。</li><li>枚举类对象不可反序列化，这也能保证每一个单例都是唯一的。</li></ol><p>因此我们可以使用单元素的枚举类型来实现单例模式。事实上，正如 <em>Effective Java</em> 一书中所说的：单元素的枚举类型已经成为实现 Singleton 的最佳方法。</p><p><em>注意</em> ：值得提出的时，由以上的分析我们知道每一个枚举都是一个对象，既然是对象，那么它所占的内存就比基本类型大很多，这就是枚举类型的缺点，所以在Android开发中并不建议使用枚举类型，而是使用<code>@interface+@IntDef/@StringDef</code>等注解加上int或者String进行替代。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/05/16/Java枚举类型原理/Java枚举.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://dongxiawu.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://dongxiawu.github.io/tags/Java/"/>
    
      <category term="Enum" scheme="https://dongxiawu.github.io/tags/Enum/"/>
    
      <category term="Singleton" scheme="https://dongxiawu.github.io/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化与反序列化</title>
    <link href="https://dongxiawu.github.io/2018/05/15/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://dongxiawu.github.io/2018/05/15/Java序列化与反序列化/</id>
    <published>2018-05-15T06:10:41.000Z</published>
    <updated>2018-05-16T03:18:55.002Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/05/15/Java序列化与反序列化/Java序列化与反序列化.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 的序列化相信大家都不陌生。当我们需要讲对象存储起来或进行传输时，就需要对 Java 对象进行序列化，那么在序列化过程中有什么需要注意的呢？</p><h1 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h1><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>当我们要序列化一个类时，可以选择实现 <em>Serializable</em> 接口，注意，这是一个 <em>标记接口</em>，也就是说这个接口并没有任何方法或者成员变量，仅仅告诉 JVM 该类可以被序列化。</p><p>例：</p><pre><code>public class Animal implements Serializable{  public int age;  public Animal(int age) {    this.age = age;  }  @Override  public String toString() {    return &quot;Animal [age=&quot; + age + &quot;]&quot;;  }}</code></pre><p>此时，该类就可以被存储或者传输了。</p><p>例：</p><pre><code>public class Main{    public static final void main(String[] args) {        ObjectOutputStream objectOutputStream = null;        try {            Animal animal = new Animal(2);            System.out.println(animal);            objectOutputStream = new ObjectOutputStream(                    new FileOutputStream(new File(&quot;file1&quot;)));            objectOutputStream.writeObject(animal);        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            try {                if (objectOutputStream != null) {                    objectOutputStream.flush();                    objectOutputStream.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }        ObjectInputStream objectInputStream = null;        try {            objectInputStream = new ObjectInputStream(                    new FileInputStream(new File(&quot;file1&quot;)));            Object object = objectInputStream.readObject();            System.out.println(object);        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            try {                if (objectInputStream != null) {                    objectInputStream.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p>输出结果：</p><pre><code>Animal [age=2]Animal [age=2]</code></pre><p>可以看到，成功的实现了对象的保存与恢复，有的时候，我们并不希望所有成员变量都进行保存，比如有一些敏感信息等。这时候就可以将不保存的成员变量声明为 <em>transient</em>,如：<code>transient public int age</code>，这样在序列化的时候就不会保存该成员变量，相应的反序列化的时候该成员变量将不会被赋值。</p><h2 id="自定义序列化逻辑"><a href="#自定义序列化逻辑" class="headerlink" title="自定义序列化逻辑"></a>自定义序列化逻辑</h2><p>默认情况下，JVM会自动帮我们做序列化和反序列化的工作，但有的时候我们想自己在序列化和反序列化的时候添加上自己的逻辑，如加解密等，这就涉及到了以下的方法：</p><ul><li>private void writeObject(java.io.ObjectOutputStream out) throws IOException;</li><li>private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;</li><li>private void readObjectNoData() throws ObjectStreamException;</li></ul><p>其中，writeObject()方法 用于保存对象的状态以便 readObject()方法进行恢复，可以调用out.defaultWriteObject 进行默认保存。写入的对象可以是有效的成员变量或者DataOutput中支持的基本类型</p><p>readObject()方法用于从数据流中恢复类的非静态和非瞬时成员变量，in.defaultReadObject()为默认的恢复方法。</p><p><em>注意</em> readObject()方法中的恢复顺序必须与与writeObject()方法中的保存顺序一致。</p><p>以上的两个方法均可以不关注属于父类或子类的成员变量。</p><p>readObjectNoData()方法比较特殊，其作用为当序列化流没有将给定的类认定为反序列化的对象的超类时，该方法可以用于初始化一个反序列化对象。其原理为调用反序列化对象的无参构造函数，并进行对应初始化。这就要求反序列化对象必须有无参构造函数。</p><p>这种情况在当接收方与发送方的反序列化类版本不同，<em>并且</em> 接收方的类继承了某些发送方没有继承的类(而没有改动类的内容);或者序列化流被篡改了，变得不完整的时候会发生。</p><p>例子：</p><pre><code>public class Main{    public static final void main(String[] args) {        ObjectOutputStream objectOutputStream = null;        try {            Persion persion = new Persion(&quot;jack&quot;);            System.out.println(persion);            objectOutputStream = new ObjectOutputStream(                    new FileOutputStream(new File(&quot;file1&quot;)));            objectOutputStream.writeObject(persion);        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            try {                if (objectOutputStream != null) {                    objectOutputStream.flush();                    objectOutputStream.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }    }}public class Persion implements Serializable {    public String name;    public Persion() {    }    public Persion (String name) {        this.name = name;    }    @Override    public String toString() {        return &quot;Persion [&quot; + &quot;name=&quot; + name +&quot;]&quot;;    }}</code></pre><p>先将 Person 对象保存起来，然后修改 Person 类，使其继承 Animal 类，并在 Animal 类中实现 readObjectNoData() 方法，最后尝试恢复对象。</p><pre><code>public class Persion extends Animal implements Serializable {    public String name;    public Persion() {    }    public Persion (String name) {        this.name = name;    }    @Override    public String toString() {        return &quot;Persion [&quot; + &quot;name=&quot; + name + &quot;, age=&quot; + age +&quot;]&quot;;    }}public class Animal implements Serializable{    transient public int age;    public Animal() {    }    public Animal(int age) {        this.age = age;    }    private void readObjectNoData() throws ObjectStreamException {        this.age = 20;    }    @Override    public String toString() {        return &quot;Animal [age=&quot; + age + &quot;]&quot;;    }}public class Main{    public static final void main(String[] args) {        ObjectInputStream objectInputStream = null;        try {            objectInputStream = new ObjectInputStream(                    new FileInputStream(new File(&quot;file1&quot;)));            Object object = objectInputStream.readObject();            System.out.println(object);        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            try {                if (objectInputStream != null) {                    objectInputStream.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p>可以发现 Animal 类的 readObjectNoData() 方法被调用了，输出结果为：<code>Persion [name=jack, age=20]</code></p><h2 id="替换序列化对象"><a href="#替换序列化对象" class="headerlink" title="替换序列化对象"></a>替换序列化对象</h2><p>有的时候，我们想将其他对象而不是当前对象进行序列化保存或传输，比如代理类的情况，这个时候就可以通过实现<br><code>Object writeReplace() throws ObjectStreamException</code><br>方法达到，该方法可以是任何访问属性，子类也遵循访问规则。</p><p>值得提出的是，反序列化的对象和原来的对象并不是同一个对象，如果这个时候对两个对象进行 <code>==</code> 测试，则结果为 <code>false</code>。有的时候，我们希望反序列化的对象和原来的对象是同一个对象，比如在单例模式的时候，这个时候可以通过实现<br><code>Object readResolve() throws ObjectStreamException;</code>方法进行反序列化对象替换。该方法可以是任何访问属性。</p><p>例：</p><pre><code>public class Animal implements Serializable{    transient public int age;    public Animal() {    }    public Animal(int age) {        this.age = age;    }    public Object readResolve() throws ObjectStreamException {        return new Animal(3);    }    @Override    public String toString() {        return &quot;Animal [age=&quot; + age + &quot;]&quot;;    }}public class Main{    public static final void main(String[] args) {        ObjectOutputStream objectOutputStream = null;        try {            Animal animal = new Animal(2);            System.out.println(animal);            objectOutputStream = new ObjectOutputStream(                    new FileOutputStream(new File(&quot;file1&quot;)));            objectOutputStream.writeObject(animal);        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            try {                if (objectOutputStream != null) {                    objectOutputStream.flush();                    objectOutputStream.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }        ObjectInputStream objectInputStream = null;        try {            objectInputStream = new ObjectInputStream(                    new FileInputStream(new File(&quot;file1&quot;)));            Object object = objectInputStream.readObject();            System.out.println(object);        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            try {                if (objectInputStream != null) {                    objectInputStream.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p>此时的输出结果为：</p><pre><code>Animal [age=2]Animal [age=3]</code></pre><h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>序列化运行时分配给每一个序列化类一个版本号，称为serialVersionUID，<br>在反序列化过程中使用该版本号来验证序列化对象的发送者和接收者是否已加载该对象的与序列化相容的类。<br>如果接收者为与对应的发送者类具有不同serialVersionUID的对象加载类，则反序列化将导致InvalidClassException异常。<br>一个可序列化的类可以通过声明一个名为serialVersionUID的字段声明自己的serialVersionUID，该字段必须是static final long<br>类型，可以是任何访问属性。</p><p>如果可序列化类没有显式声明serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认serialVersionUID值，<br>如Java（TM）对象序列化规范中所述。然而，强烈建议所有可序列化的类显式声明serialVersionUID值，因为默认的serialVersionUID计算对类详细信息高度敏感，<br>可能因编译器实现而异，因此可能会导致在反序列化过程中抛出InvalidClassException。<br>因此，要确保跨不同的java编译器实现保持一致的serialVersionUID值，可序列化的类必须声明显式的serialVersionUID值。<br>还强烈建议显式serialVersionUID声明尽可能使用 <em>private</em> 修饰符，因为这些声明仅适用于立即声明的类<br>serialVersionUID字段作为继承成员是无用的。<br>数组类无法声明显式的serialVersionUID，因此它们始终具有默认的计算值，<br>但是对于数组类而言，不需要匹配serialVersionUID值。</p><h1 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h1><p>序列化的接口除了 Serializable 还有 Externalizable，二者的不同在于 Externalizable 有以下的两个方法：</p><ul><li>void writeExternal(ObjectOutput out) throws IOException;</li><li>void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;</li></ul><p>通过实现 <code>Externalizable</code> 接口实现序列化的类除了需要控制该类成员变量的的保存与恢复，还需要控制其父类成员变量的保存与恢复。 其通过上述的两个方法实现。</p><p>例子：</p><pre><code>public class Animal implements Serializable{    transient public int age;    public Animal() {    }    public Animal(int age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Animal [age=&quot; + age + &quot;]&quot;;    }}public class Persion extends Animal implements Externalizable {    public String name;    public Persion() {    }    public Persion (String name, int age) {        this.name = name;        this.age = age;    }    @Override    public void writeExternal(ObjectOutput out) throws IOException {        out.writeObject(name);    }    @Override    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{        name = (String )in.readObject();    }    @Override    public String toString() {        return &quot;Persion [&quot; + &quot;name=&quot; + name + &quot;, age=&quot; + age +&quot;]&quot;;    }}public class Main{    public static final void main(String[] args) {        ObjectOutputStream objectOutputStream = null;        try {            Persion persion = new Persion(&quot;Jack&quot;, 25);            System.out.println(persion);            objectOutputStream = new ObjectOutputStream(                    new FileOutputStream(new File(&quot;file1&quot;)));            objectOutputStream.writeObject(persion);        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            try {                if (objectOutputStream != null) {                    objectOutputStream.flush();                    objectOutputStream.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }        ObjectInputStream objectInputStream = null;        try {            objectInputStream = new ObjectInputStream(                    new FileInputStream(new File(&quot;file1&quot;)));            Object object = objectInputStream.readObject();            System.out.println(object);        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            try {                if (objectInputStream != null) {                    objectInputStream.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p>其输出结果为：</p><pre><code>Persion [name=Jack, age=25]Persion [name=Jack, age=0]</code></pre><p>故表明通过实现 <code>Externalizable</code> 接口实现序列化的类除了需要控制该类成员变量的的保存与恢复，还需要控制其父类成员变量的保存与恢复。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/05/15/Java序列化与反序列化/Java序列化与反序列化.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://dongxiawu.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://dongxiawu.github.io/tags/Java/"/>
    
      <category term="Serializable" scheme="https://dongxiawu.github.io/tags/Serializable/"/>
    
      <category term="Externalizable" scheme="https://dongxiawu.github.io/tags/Externalizable/"/>
    
  </entry>
  
  <entry>
    <title>Intent与IntentFilter</title>
    <link href="https://dongxiawu.github.io/2018/05/04/Intent%E4%B8%8EIntentFilter/"/>
    <id>https://dongxiawu.github.io/2018/05/04/Intent与IntentFilter/</id>
    <published>2018-05-04T08:20:51.000Z</published>
    <updated>2018-05-04T11:44:26.559Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/05/04/Intent与IntentFilter/Intent与IntentFilter.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Intent 这个类相信大家都不陌生。这个类的中文名称为 <em>意图</em> ,主要用于 Android 四大组件之间传递信息。那么这个类有什么值得注意的地方呢？还有 Intent 和 IntentFilter 之间是如何匹配的呢？</p><h1 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h1><p>了解一个类最直接的方式就是查看源码，所以我们通过源码首先看看 Intent 这个类有哪些成员变量。</p><pre><code>private String mAction;private Uri mData;private String mType;private String mPackage;private ComponentName mComponent;private int mFlags;private ArraySet&lt;String&gt; mCategories;private Bundle mExtras;private Rect mSourceBounds;private Intent mSelector;private ClipData mClipData;private int mContentUserHint = UserHandle.USER_CURRENT;private String mLaunchToken;</code></pre><p>其实从 Intent 的成员变量中我们已经可以大概知道 Intent 的作用了。<br>我们知道 Intent 有显式和隐式之分，其中，显式 Intent 主要设置的就是 ComponentName mComponent 这个成员变量，比如：</p><pre><code>Intent intent = new Intent(MainActivity.this,SecondActivity.class);startActivity(intent);</code></pre><p>而隐式 Intent 主要设置的就是以下的几个成员变量</p><pre><code>private String mAction;private Uri mData;private String mType;private ArraySet&lt;String&gt; mCategories;</code></pre><p>从中我们可以得出，Action、Data、Type 都最多只有一个值，而 Category 可以有多个值。</p><p>隐式 Intent 的主要使用方式为：</p><pre><code>Intent intent = new Intent();intent.setAction(Intent.ACTION_SEND);intent.addCategory(Intent.CATEGORY_APP_BROWSER);startActivity(intent);</code></pre><p>注意，若需要同时设置Data和Type两个属性时，必须使用setDataAndType()方法，不要同时调用setData()和setType()方法，因为这两个方法设置的值会相互覆盖</p><pre><code>public Intent setData(Uri data) {    mData = data;    mType = null;    return this;}public Intent setType(String type) {    mData = null;    mType = type;    return this;}</code></pre><h1 id="IntentFilter"><a href="#IntentFilter" class="headerlink" title="IntentFilter"></a>IntentFilter</h1><p>当设置完 Intent 对象后，要启动的是哪个组件呢？这就由 IntentFilter 决定了。</p><p>IntentFilter 通常在 AndroidManifest.xml 中设置，如：</p><pre><code>&lt;activity android:name=&quot;.MainActivity&quot;&gt;  &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;  &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>与 Intent 相同，我们先看一下 IntentFilter 的成员变量如下：</p><pre><code>private int mPriority;private int mOrder;private final ArrayList&lt;String&gt; mActions;private ArrayList&lt;String&gt; mCategories = null;private ArrayList&lt;String&gt; mDataSchemes = null;private ArrayList&lt;PatternMatcher&gt; mDataSchemeSpecificParts = null;private ArrayList&lt;AuthorityEntry&gt; mDataAuthorities = null;private ArrayList&lt;PatternMatcher&gt; mDataPaths = null;private ArrayList&lt;String&gt; mDataTypes = null;private boolean mHasPartialTypes = false;</code></pre><p>从中我们可以看到，由于Action，Category，DataType 等都是链表，所以 IntentFilter 中，Action、Data、Type 都允许有多个值。</p><p>而且每一个组件都允许存在多个 IntentFilter。</p><p>至于 Intent 和 IntentFilter 之间的匹配规则为：</p><p>显式 Intent：直接通过类名查找，故不需要 IntentFilter。</p><p>隐式 Intent：它必须有一个IntentFilter 的<category>属性包含CATEGORY_DEFAULT，因为startActivity()和startActivityForResult()方法处理 隐式Intent 时候，默认的认为接受组件有一个<category>属性为CATEGORY_DEFAULT的过滤器。如果一个Activity组件不声明这样一个过滤器，它就接收不到 隐式Intent。</category></category></p><p>IntentFilter 必须包含 Intent 的 Action 属性（如果 Intent 有）</p><p>IntentFilter 必须包含 Intent 的所有 Category 属性（如果 Intent 有），同时必须有<br>一个 Category 的属性值为CATEGORY_DEFAULT。</p><p>每个Data属性都可以指定数据的URI结构和数据MIME类型。URI包括scheme、host、port 和path四个部分，host和port合起来也成authority（host:port）部分。</p><p><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></p><p>例如：</p><p>content://192.168.0.1:8080/folder/subfolder/etc</p><p>在这个URI中，scheme是content，host是192.168.0.1，port是8080，path是folder/subfolder/etc。我们平时使用的网络url就是这种格式。</p><p>匹配规则：</p><p>在URI中，每个组成部分都是可选的，但是有线性的依赖关系</p><p>如果没有scheme部分，那么host部分会被忽略</p><p>如果没有host部分，那么port部分会被忽略</p><p>如果host部分和port部分都没有，那么path部分会被忽略</p><p>当进行URI匹配时候，并不是比较全部，而是局部对比，以下是URI匹配规则。</p><p>如果一个URI仅声明了scheme部分，那么所有拥有与其相同的scheme的URI都会通过匹配，其他部分不做匹配</p><p>如果一个URI声明了scheme部分和authority部分，那么拥有与其相同scheme和authority的URI才能匹配成功，path部分不做匹配</p><p>如果一个URI所有的部分都声明了，那么只有所有部分都相同的URI才能匹配成功</p><p>注意：path部分可以使用通配符<code>*</code>，也就是path其中的一部分进行匹配。</p><p>Data匹配时候，MIME类型和URI两者都会进行匹配，匹配规则如下：</p><p>如果过滤器未声明URI和MIME类型，则只有不含URI和MIME类型的隐式Intent才能匹配成功</p><p>如果过滤器中声明URI但是未声明MIME类型（也不能从URI中分析出MIME类型），则只有URI与过滤器URI相同且不包含IME类型的隐式Intent才能匹配成功</p><p>如果过滤器声明MIME类型但是未声明URI，只有包含相同MIME类型但是不包含URI的隐式Intent才能匹配成功</p><p>如果过滤器声明了URI和MIME类型（既可以是直接设置，也可以是从URI分析出来），只有包含相同的URI和MIME类型的隐式Intent才能匹配成功</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/05/04/Intent与IntentFilter/Intent与IntentFilter.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://dongxiawu.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://dongxiawu.github.io/tags/Android/"/>
    
      <category term="Intent" scheme="https://dongxiawu.github.io/tags/Intent/"/>
    
      <category term="IntentFilter" scheme="https://dongxiawu.github.io/tags/IntentFilter/"/>
    
  </entry>
  
  <entry>
    <title>Java注解与注解处理器</title>
    <link href="https://dongxiawu.github.io/2018/04/18/Java%E6%B3%A8%E8%A7%A3%E4%B8%8E%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://dongxiawu.github.io/2018/04/18/Java注解与注解处理器/</id>
    <published>2018-04-18T07:43:06.000Z</published>
    <updated>2018-05-04T08:20:23.353Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/04/18/Java注解与注解处理器/Java注解与注解处理器.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><a id="more"></a><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p>@Retention：保留期，表示注解的存活时间，取值为：</p><ul><li>RetentionPolicy.SOURCE：注解只在源码阶段保留，编译后忽略，主要起到提示、警告的作用，如@Override</li><li>RetentionPolicy.CLASS：注解保留到编译后的class文件中，运行时忽略，即不会加载到虚拟机中，但是可以通过读文件的形式获取class文件中的注解，该类注解可以在编译时进行规则检查或自动生成某些代码，如@NonNull</li><li>RetentionPolicy.RUNTIME：注解保留到运行时，可以在运行时获取，可以用作动态条件判断等功能，如@Inherited、@Documented</li></ul><h2 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h2><p>@Documented:文档，含有该注解的注解能够被javadoc生成java文档</p><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>@Target：表示该注解的作用范围，取值为：</p><ul><li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li><li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li><li>ElementType.FIELD 可以给属性进行注解</li><li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li><li>ElementType.METHOD 可以给方法进行注解</li><li>ElementType.PACKAGE 可以给一个包进行注解</li><li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li><li>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li></ul><h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p>@Inherited：表示该注解是否可以被继承，当父类使用了可继承的注解，子类默认也含有该注解</p><h2 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h2><p>@Native：表示变量来自本地代码</p><h2 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h2><p>@Repeatable：Java 1.8新增，代表注解的类可以有多个取值</p><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Java中，可以使用@interface关键字创建自定义注解：</p><pre><code>@Documented@Target(ElementType.METHOD)@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface MethodInfo {    String author() default &quot;&quot;;    String date();    int version() default 1;    String comments();}</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用@interface自定义注解时，自动继承了 java.lang.annotation.Annotation 接口</li><li>注解中的方法，实际是声明了一个配置参数，参数名称就是方法名，返回值类型智能是基本类型、Class、String、enum、Annotation以及前面类型的数组。可以通过default来声明参数默认值。</li><li>注解中的方法，不允许使用project、private修饰符，也无需加上public修饰符，这一点和接口类似。</li><li>自定义注解需要在前面加上元注解，用以表示注解的使用方式及范围。</li></ul><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><pre><code>@MethodInfo(comments = &quot;test method&quot;, author = &quot;dongxiawu&quot;, date = &quot;2018-04-18&quot;, version = 1)public String testMethod() {    return &quot;test method&quot;;}</code></pre><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>接口中有默认值的属性，在使用时可以忽略，而没有默认值的属性则不能忽略，否则会报错。</li></ul><h1 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>在代码中解析注解需要使用Java的反射机制，但只能解析 Retention 为 RetentionPolicy.RUNTIME 的注解。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>public class Main {    public static void main(String[] args){        for (Method method : Main.class.getMethods()){            if (method.isAnnotationPresent(MethodInfo.class)){                MethodInfo methodInfo = method.getAnnotation(MethodInfo.class);                System.out.println(&quot;comments: &quot; + methodInfo.comments() + &quot; author: &quot; + methodInfo.author()                        + &quot; date:&quot; + methodInfo.date() + &quot; version: &quot; + methodInfo.version());            }        }    }    @MethodInfo(comments = &quot;test method&quot;, author = &quot;dongxiawu&quot;, date = &quot;2018-04-18&quot;, version = 1)    public String testMethod() {        return &quot;test method&quot;;    }}</code></pre><h1 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h1><p>在运行时进行注释解析只能解析只能解析 Retention 为 RetentionPolicy.RUNTIME 的注解，对于  Retention 为 RetentionPolicy.SOURCE 和 RetentionPolicy.CLASS 的注解由于分别在编译完成后和加载到JVM时消除了，所以不能在运行时获取到，这时就需要注解处理器，在编译器是能够获取注解并进行相应操作。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>注解处理器(Annotation Processor)是javac内置的一个用于编译时扫描和处理注解(Annotation)的工具。简单的说，在源代码编译阶段，通过注解处理器，我们可以获取源文件内注解(Annotation)相关内容。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>由于注解处理器可以在程序编译阶段工作，所以我们可以在编译期间通过注解处理器进行我们需要的操作。比较常用的用法就是在编译期间获取相关注解数据，然后动态生成.java源文件（让机器帮我们写代码），通常是自动产生一些有规律性的重复代码，解决了手工编写重复代码的问题，大大提升编码效率。</p><p>另外一点好处就是由于是在编译器对代码进行处理，所以对代码的运行效率没有影响。（如果是在运行时对注解进行处理，如Retention 为 RetentionPolicy.RUNTIME 的注解，则会占用运行时间）</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>定义自己的注解处理器，首先要继承 Processor 接口，不过为了不实现接口的全部方法，可以选择继承 AbstractProcessor 抽象类，并实现 process 方法。</p></li><li><p>在编译期间使用自己定义的注解处理器，主要有两种方法：</p><ol><li>使用 <code>-processor</code> 选项指定注解处理器的位置，如 <code>javac -processor Myprocessor Main.java</code></li><li>将注解处理器打包成jar包，并采用<code>-processorpath</code>等选项指定路径，如<code>javac -processorpath processor.jar Main.java</code>，同时还需要在 jar 包中添加自定义的 processor 类名信息，以便编译过程中能够找到正确的 Processor，具体方法为：在 META-INF/services/ 文件夹下新建 javax.annotation.processing.Processor 文件，并在其中添加对应的 processor 类名信息。</li></ol></li></ol><p>注：也可以使用 gradle 自动构建，如google 的 <code>com.google.auto.service:auto-service</code> 库</p><h2 id="使用例子-1"><a href="#使用例子-1" class="headerlink" title="使用例子"></a>使用例子</h2><pre><code>@Target(ElementType.TYPE)@Retention(RetentionPolicy.SOURCE)@Documentedpublic @interface Persistent {    String table();}@Target(ElementType.FIELD)@Retention(RetentionPolicy.SOURCE)@Documentedpublic @interface Id {    String column();    String type();    String generator();}@Documented@Target(ElementType.FIELD)@Retention(RetentionPolicy.SOURCE)public @interface Property {    String column();    String type();}@Persistent(table = &quot;persion_inf&quot;)public class Persion {    @Id(column = &quot;person_id&quot;, type = &quot;integer&quot;, generator = &quot;identity&quot;)    private int id;    @Property(column = &quot;person_name&quot;, type = &quot;string&quot;)    private String name;    @Property(column = &quot;person_age&quot;, type = &quot;integer&quot;)    private int age;    public Persion(){    }    public Persion(int id, String name, int age){        this.id = id;        this.name = name;        this.age = age;    }}@SupportedSourceVersion(SourceVersion.RELEASE_8)@SupportedAnnotationTypes({&quot;Persistent&quot;,&quot;Property&quot;,&quot;Id&quot;})public class MyProcessor extends AbstractProcessor {    Elements elementUtils;    @Override    public synchronized void init(ProcessingEnvironment processingEnv) {        super.init(processingEnv);        elementUtils = processingEnv.getElementUtils();    }    @Override    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {        PrintStream ps = null;        try {            for (Element t : roundEnv.getElementsAnnotatedWith(Persistent.class)){                Name clazzName = t.getSimpleName();                Persistent per = t.getAnnotation(Persistent.class);                ps = new PrintStream(new FileOutputStream(clazzName + &quot;.txt&quot;));                ps.println(&quot;table: &quot; + per.table());                for (Element f : t.getEnclosedElements()){                    if (f.getKind() == ElementKind.FIELD){                        Id id = f.getAnnotation(Id.class);                        if (id != null){                            ps.println(&quot;id: &quot; +&quot; name: &quot; + f.getSimpleName() +&quot; column: &quot; + id.column()                                    + &quot; type: &quot; + id.type() + &quot; generator: &quot; + id.generator());                        }                        Property property = f.getAnnotation(Property.class);                        if (property != null){                            ps.println(&quot;property: &quot; +&quot; name: &quot; + f.getSimpleName() +&quot; column: &quot; + property.column()                                    + &quot; type: &quot; + property.type());                        }                    }                }            }        }catch (Exception e){            e.printStackTrace();        }finally {            if (ps != null){                try {                    ps.close();                }catch (Exception e){                    e.printStackTrace();                }            }        }        return true;    }}</code></pre><p>编译命令 <code>javac -processor MyProcessor Persion.java</code></p><p>结果输出一个文件，内容为：</p><pre><code>table: persion_infid:  name: id column: person_id type: integer generator: identityproperty:  name: name column: person_name type: stringproperty:  name: age column: person_age type: integer</code></pre><h2 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h2><p>自定义注解处理器前可以加上三个注解</p><ul><li>@SupportedSourceVersion()：支持版本</li><li>@SupportedAnnotationTypes()：支持的注解</li><li>@SupportedOptions()：支持的选项</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/04/18/Java注解与注解处理器/Java注解与注解处理器.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://dongxiawu.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://dongxiawu.github.io/tags/Java/"/>
    
      <category term="注解" scheme="https://dongxiawu.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="注解处理器" scheme="https://dongxiawu.github.io/tags/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android权限管理</title>
    <link href="https://dongxiawu.github.io/2018/04/16/Android%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>https://dongxiawu.github.io/2018/04/16/Android权限管理/</id>
    <published>2018-04-16T08:43:32.000Z</published>
    <updated>2018-05-04T08:20:22.908Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/04/16/Android权限管理/Android权限管理.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><a id="more"></a><p>我们知道，在Android 6.0之前，当我们的应用需要某项权限时，只要在 AndroidManifest.xml 中添加对应的权限就好了。安装应用的时候会列出所有应用要求的权限，只有同意了才能继续安装。这样做虽然比较简单，但是却有两个比较大的缺点：</p><ol><li>安装时列出的权限通常比较多，用户往往没有仔细看就点了同意，这样就让应用获取了一些非必须的权限，并利用这些权限非法收集用户信息，这也是 Android 被大众所诟病的原因之一。</li><li>如果用户并不想赋予应用某些权限，那么应用就不能安装，这种交互逻辑影响了用户体验，因为有些权限并不是运行应用必须的，或者说没有该权限应用一样可以运行。</li></ol><p>因此，从 Android 6.0 开始，Google 改变了 Android 的权限处理逻辑。大致逻辑如图所示：<br><img src="/2018/04/16/Android权限管理/Android权限分类.jpg"><br>从图中我们可以看出，Google把权限分成两类，具体为：</p><ol><li>Normal：普通的权限，如网络，获取时区等，具体普通权限的列表可以在网上找到。处理这些权限如同的方式Android 6.0之前一样，只要在 AndroidManifest.xml 中添加对应的权限就好了。</li><li>Dangerous：危险的权限，如打电话，获取联系人，读写SD卡等，这些权限在Android 6.0 后在 AndroidManifest.xml 中设置是无效的，必须在运行的时候动态获取，因此也称为动态权限。但是要注意的是，所有危险权限中有两个特殊的权限，即悬浮框权限和运行修改系统设置权限，这两个权限不能动态获取，必须引导用户自己到设置界面进行设置才能生效。</li></ol><p>因此在 Android 6.0 之后，安装应用程序时不会列出所有的权限了，而是在使用应用的过程中动态获取。用户没有授权一些非必要的权限也不会导致用户的崩溃。这样一来既提高了用户体验，也让用户的数据更加安全。但也同时带来了开发难度加大的缺点，我们来梳理一下动态权限的逻辑。<br><img src="/2018/04/16/Android权限管理/Android动态权限获取逻辑.jpg"></p><ol><li>在需要某个危险权限的时候，需要首先判断是否已经获得了该权限，如果没有，则应该弹出对话框询问用户是否授权。</li><li>当用户拒绝授权的时候，应该判断该权限是否必须的，从而判断是退出程序还是继续运行。</li><li>当用户曾经拒绝过该权限时，还应该考虑是否向用户解释为什么需要该权限，以便让用户顺利授权。具体方法为shouldShowRequestPermissionRationale(String permission)。当第一次申请该权限时，返回false，当第二次及以上申请该权限时，返回true。若用户已经选择了不再提示，则返回false。</li><li>若用户选择了不再提示，则下次需要该权限时，应该提醒用户手动到设置界面进行设置，因为这个时候权限授权对话框将不再弹出。</li></ol><p>注： 由于 Android 的开放性，各个厂家都对系统做了修改，在实际使用过程中发现，有些手机即使查询到某权限已经授权，但在使用过程中还是会发生错误。针对这种情况，可以先尝试用代码测试是否改权限真正授权了（申请联系人权限时尝试如写入一个测试联系人数据）。如果失败，则弹出对话框或引导用户进行授权。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/04/16/Android权限管理/Android权限管理.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android权限管理" scheme="https://dongxiawu.github.io/categories/Android%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Android" scheme="https://dongxiawu.github.io/tags/Android/"/>
    
      <category term="权限管理" scheme="https://dongxiawu.github.io/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>butterknife详解之源码结构分析</title>
    <link href="https://dongxiawu.github.io/2018/02/14/butterknife%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>https://dongxiawu.github.io/2018/02/14/butterknife详解之源码结构分析/</id>
    <published>2018-02-14T13:12:34.000Z</published>
    <updated>2018-05-04T08:20:23.479Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/02/14/butterknife详解之源码结构分析/logo.png"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>学习完 butterknife 的基本使用之后，本文主要讲解 butterknife 源码的组织结构。</p><a id="more"></a><h1 id="源码构成"><a href="#源码构成" class="headerlink" title="源码构成"></a>源码构成</h1><p>首先我们来看一下 butterknife 的源码构成。</p><img src="/2018/02/14/butterknife详解之源码结构分析/butterknife源码构成.png"><p>其中</p><ul><li>butterknife ;主模块，提供android使用的API</li><li>butterknife-annotations; 注解模块，提供了所需的注解</li><li>butterknife-compiler；注解编译模块，提供了编译时用到的注解的处理器</li><li>butterknife-gradle-plugin；插件模块，自定义的gradle插件，辅助生成有关代码</li><li>butterknife-integration-test；该项目的测试用例模块</li><li>butterknife-lint；该项目的静态代码检查模块</li><li>sample；demo</li></ul><p>从源码组成结构我们可以看出，库的结构非常清晰，基本上按功能分成了7个模块。</p><h1 id="butterknife模块结构"><a href="#butterknife模块结构" class="headerlink" title="butterknife模块结构"></a>butterknife模块结构</h1><img src="/2018/02/14/butterknife详解之源码结构分析/butterknife模块结构.png"><p>可以看到，butterknife模块一共只有5个类，而且供客户端使用的只有 Butterknife 和 Unbinder 两个类，可以说将设计原则都应用得淋漓精致。</p><ul><li><p>DebouncingOnClickListener:按钮去抖，其原理时每次按钮按下时禁止按钮短时间内重复按下，处理按钮事件同时另起一个线程重新使能按钮。核心代码为：</p><pre><code>@Override public final void onClick(View v) {    if (enabled) {      enabled = false;      v.post(ENABLE_AGAIN);      doClick(v);    }  }</code></pre></li><li><p>ImmutableList 将视图数组转换成不可变链表，该方法比系统自带的方法 Collections.unmodifiableList(); 轻量</p></li><li><p>Utils 实用方法，主要供生成的代码使用，如获取系统资源等。</p></li><li><p>Unbinder 控件解绑接口，当控件不再使用时应该解绑，避免内存泄露。</p></li><li><p>Butterknife</p></li></ul><img src="/2018/02/14/butterknife详解之源码结构分析/butterknife方法.png"><p>从 Butterknife 的方法列表中可以看出 Butterknife类主要做了两件事</p><ol><li><p>绑定(bind)：</p><p>其中，绑定的对象可以是 View、Activity、Dialog</p><p>其步骤及原理是：</p><ol><li>将 Activity、Dialog、View 等提供控件信息的对象等作 target 参数。</li><li>从 Activity、Dialog、View 等中找到根视图作为 source 参数。</li><li>生成一个类，类名为 target_ViewBinding，该类持有  target 引用，并实现 Unbinder 接口。</li><li>从 target 引用中获取控件名和对应的布局id，从 source 中找到对应视图，进行绑定。</li></ol></li><li><p>应用(apply)<br>将 Action、Setter、Property 等操作应用在对应的控件上。其原理是实现 Action、Setter、Property 等接口，并通过ButterKnife.apply()方法应用在对应的控件上。</p></li></ol><p>到这里 butterknife模块结构 就全部介绍完毕了。下一节介绍 butterknife 的注解系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/02/14/butterknife详解之源码结构分析/logo.png&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习完 butterknife 的基本使用之后，本文主要讲解 butterknife 源码的组织结构。&lt;/p&gt;
    
    </summary>
    
      <category term="butterknife" scheme="https://dongxiawu.github.io/categories/butterknife/"/>
    
    
      <category term="butterknife" scheme="https://dongxiawu.github.io/tags/butterknife/"/>
    
      <category term="开源库" scheme="https://dongxiawu.github.io/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>butterknife详解之butterknife的基本使用</title>
    <link href="https://dongxiawu.github.io/2018/02/13/butterknife%E8%AF%A6%E8%A7%A3%E4%B9%8Bbutterknife%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://dongxiawu.github.io/2018/02/13/butterknife详解之butterknife的基本使用/</id>
    <published>2018-02-13T04:29:45.000Z</published>
    <updated>2018-05-04T08:20:23.354Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/02/13/butterknife详解之butterknife的基本使用/logo.png"><p>butterknife 是有 Android 之神之称的 JakeWharton 开发的一个依赖注入框架，可以帮助开发者快速地完成初始化控件等重复性工作。其原理是通过注解处理器生成中间代码完成控件初始化工作。关于 butterknife 的更多信息可以访问其主页：<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">butterknife主页</a></p><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>本文主要讲解 butterknife 的基本使用</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>  在 android 工程的构建脚本下添加如下内容并点击同步</p><pre><code>dependencies {  compile &apos;com.jakewharton:butterknife:8.8.1&apos;  annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos;}</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>butter主要有一下的使用场景</p><h2 id="绑定Activity"><a href="#绑定Activity" class="headerlink" title="绑定Activity"></a>绑定Activity</h2><ol><li><p>新建工程，布局如下：</p><img src="/2018/02/13/butterknife详解之butterknife的基本使用/activity布局.png"></li><li><p>声明控件，代码如下：</p><pre><code>@BindView(R.id.text1)TextView textView1;@BindView(R.id.text2)TextView textView2;@BindView(R.id.text3)TextView textView3;</code></pre></li><li><p>绑定控件，代码如下：</p><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) {  super.onCreate(savedInstanceState);  setContentView(R.layout.activity_main);  mUnbinder = ButterKnife.bind(this);}</code></pre></li><li><p>测试效果</p><pre><code>textView1.setText(&quot;I am text1&quot;);textView2.setText(&quot;I am text2&quot;);textView3.setText(&quot;I am text3&quot;);</code></pre><img src="/2018/02/13/butterknife详解之butterknife的基本使用/绑定activity效果.jpeg"></li><li><p>解绑<br>使用完毕之后需要对控件进行解绑定</p><pre><code>protected void onDestroy() {    super.onDestroy();    mUnbinder.unbind();}</code></pre></li></ol><h2 id="绑定Fragment"><a href="#绑定Fragment" class="headerlink" title="绑定Fragment"></a>绑定Fragment</h2><ol><li><p>绑定Fragment和绑定Activity基本一样，只是把绑定的步骤放在onCreateView()方法中，代码如下：</p><pre><code>public View onCreateView(LayoutInflater inflater, ViewGroup container,                         Bundle savedInstanceState) {    // Inflate the layout for this fragment    View root = inflater.inflate(R.layout.fragment_main, container, false);    mUnbinder = ButterKnife.bind(this, root);    textView1.setText(&quot;I am text1&quot;);    textView2.setText(&quot;I am text2&quot;);    textView3.setText(&quot;I am text3&quot;);    return root;}</code></pre></li></ol><img src="/2018/02/13/butterknife详解之butterknife的基本使用/绑定fragment效果.jpeg"><h2 id="绑定多个控件"><a href="#绑定多个控件" class="headerlink" title="绑定多个控件"></a>绑定多个控件</h2><pre><code>@BindViews({ R.id.first_name, R.id.middle_name, R.id.last_name })List&lt;EditText&gt; nameViews;//nameViews的集中中添加了三个edittext对象</code></pre><h2 id="绑定资源"><a href="#绑定资源" class="headerlink" title="绑定资源"></a>绑定资源</h2><ol><li><p>绑定字符串</p><p>@BindString(R.string.title) String title;</p></li><li><p>绑定图形</p><p>@BindDrawable(R.drawable.graphic) Drawable graphic;</p></li><li><p>绑定颜色</p><p>@BindColor(R.color.red) int red;</p></li><li><p>绑定长度</p><p>@BindDimen(R.dimen.spacer) Float spacer;</p></li></ol><h2 id="绑定OnCLick事件"><a href="#绑定OnCLick事件" class="headerlink" title="绑定OnCLick事件"></a>绑定OnCLick事件</h2><pre><code>@OnClick(R.id.button)void onClick(){    Toast.makeText(this,&quot;on click&quot;,Toast.LENGTH_SHORT).show();}</code></pre><h2 id="一次性改变集合中所有对象的值"><a href="#一次性改变集合中所有对象的值" class="headerlink" title="一次性改变集合中所有对象的值"></a>一次性改变集合中所有对象的值</h2><pre><code>@BindViews({ R.id.first_name, R.id.middle_name, R.id.last_name })List&lt;EditText&gt; nameViews;ButterKnife.Action&lt;View&gt; DISABLE = new ButterKnife.Action&lt;View&gt;() {    @Override    public void apply(@NonNull View view, int index) {        view.setEnabled(false);    }};ButterKnife.Setter&lt;View,Boolean&gt; ENABLE = new ButterKnife.Setter&lt;View, Boolean&gt;() {    @Override    public void set(@NonNull View view, Boolean value, int index) {        view.setEnabled(value);    }};ButterKnife.apply(nameViews,DISABLE);ButterKnife.apply(nameViews,ENABLE,false);</code></pre><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>在使用 butterknife 的过程中，可以使用插件快速生成注解</p><ol><li>AndroidStudio -&gt; Settings -&gt; Plugin -&gt; Brouse repositories -&gt; butterknife<img src="/2018/02/13/butterknife详解之butterknife的基本使用/butterknife插件安装.png"></li><li>重启AndroidStudio</li><li>要生成注解的布局 -&gt; 右键 -&gt; Generate -&gt; Generate Butterknife Injections</li><li>指定控件和对应的变量名<img src="/2018/02/13/butterknife详解之butterknife的基本使用/生成注解.png"></li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>控件不能是不能是 static 或者 private 的</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/02/13/butterknife详解之butterknife的基本使用/logo.png&quot;&gt;
&lt;p&gt;butterknife 是有 Android 之神之称的 JakeWharton 开发的一个依赖注入框架，可以帮助开发者快速地完成初始化控件等重复性工作。其原理是通过注解处理器生成中间代码完成控件初始化工作。关于 butterknife 的更多信息可以访问其主页：&lt;a href=&quot;https://github.com/JakeWharton/butterknife&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;butterknife主页&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文主要讲解 butterknife 的基本使用&lt;/p&gt;
    
    </summary>
    
      <category term="开源库" scheme="https://dongxiawu.github.io/categories/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
      <category term="butterknife" scheme="https://dongxiawu.github.io/tags/butterknife/"/>
    
      <category term="开源库" scheme="https://dongxiawu.github.io/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式</title>
    <link href="https://dongxiawu.github.io/2018/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongxiawu.github.io/2018/02/07/设计模式之迭代器模式/</id>
    <published>2018-02-07T14:44:09.000Z</published>
    <updated>2018-05-04T08:20:23.524Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/02/07/设计模式之迭代器模式/下一个.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>迭代器模式：提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p><a id="more"></a><p>迭代器模式（Iterator）是我们在日常编程时经常使用到的模式，比如在遍历某个List或者Map的时候。</p><p>首先我们来看一下迭代器模式的 UML 图</p><img src="/2018/02/07/设计模式之迭代器模式/迭代器模式UML.png"><p>从 UML 图中我们可以看出迭代器模式的几个特点：</p><ol><li>迭代器是一个接口，定义了遍历聚合对象的操作，比如next()方法。</li><li>由具体的聚合类实现各自的迭代器，从而把迭代操作的具体实现屏蔽起来。</li><li>所有的聚合类都有生成迭代器的方法可以生成对应的迭代器。</li></ol><p>分析完迭代器模式的特点，我们可以通过一个简单的例子来具体说明迭代器模式是如何工作的。</p><p>假设我们要使用迭代器模式遍历一个名字列表，首先应该创建迭代器结构，定义了如何遍历列表。</p><pre><code>public interface Iterator {boolean hasNext();Object next();}</code></pre><p>接下来定义容器类接口，包含了生成迭代器的方法</p><pre><code>public interface Container {    Iterator getIterator();}</code></pre><p>接下来定义具体的容器类，每个容器类各自实现对应的迭代器类</p><pre><code>public class NameRepository implements Container {    public String names[] = {&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;};    @Override    public Iterator getIterator() {        return new NameIterator();    }    private class NameIterator implements Iterator {        int index;        @Override        public boolean hasNext() {            if(index &lt; names.length){                return true;            }            return false;        }        @Override        public Object next() {            if(this.hasNext()){                return names[index++];            }            return null;        }    }}</code></pre><p>这样我们就可以简单地实现遍历名字列表的功能了</p><pre><code>public class Main {    public static void main(String[] agrs){        NameRepository namesRepository = new NameRepository();        for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){            String name = (String)iter.next();            System.out.println(&quot;Name : &quot; + name);        }    }}</code></pre><p>可能到这里你会有一个疑问，我可以直接使用数组存放名字，然后通过数组下标遍历名字，这样不是更加简单吗？当然可以，但是我们说好的程序应该有以下几个特点：</p><ol><li>易于扩展</li><li>耦合性低</li></ol><p>如果你用了数组实现了遍历，那么如果下一次需要添加一个删除某个位置插入或删除一个名字的功能，那么用数组实现的复杂度是O(n)，而用链表实现的复杂度是O(1)，这个时候你可能会想使用链表来实现，但是你前面的所有功能都是基于数组实现的，所以你不得不全部重写一遍。而如果你使用了迭代器模式，因为客户端只是使用了getIterator()方法生成迭代器，并没有暴露出具体的实现，所以只需要修改聚合类内部的迭代器实现就可以了。</p><p>但是迭代器模式也有一些缺点</p><ol><li>由于每一个具体的聚合类都要实现对应的迭代器，所以代码量会比较多，略显繁琐。</li><li>由于迭代器提供了一种方法去访问聚合类的元素，在一定程度上破坏了聚合类的封闭性。</li></ol><p>最后，如果你去仔细看看 Java 的源码，会发现其实 Java 源码已经实现了迭代器模式了。其中 Collection 接口就是聚合类接口， Iterator 接口就是迭代器接口，List，Map等类就是具体的聚合类，每个聚合类内都实现了各自的迭代器类。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/02/07/设计模式之迭代器模式/下一个.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;迭代器模式：提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://dongxiawu.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之组合模式</title>
    <link href="https://dongxiawu.github.io/2018/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongxiawu.github.io/2018/02/06/设计模式之组合模式/</id>
    <published>2018-02-06T03:01:28.000Z</published>
    <updated>2018-05-04T08:20:23.522Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/02/06/设计模式之组合模式/多重身份.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>组合模式（Composite）允许你将对象组合成树形结构来表现“整体/部分”层次结构。</p><a id="more"></a><p>说到组合模式，Android 开发者们第一反应都会想到 View/ViewGroup。没错，View/ViewGroup 正是通过组合模式使用户能够以树状的形式访问它们。那么组合模式究竟是如何实现的呢？首先看一下组合模式的 UML 图。</p><p>假设我们现在有这么一个需求：需要按部门和等级建立公司的人员结构图，由于公司的组织结构和人员变动随时都有可能发生，所以，所以不能采用一个固定的数据结构。这种情况下使用组合模式是一个很好的选择。</p><p>我们尝试从组合模式的UML中找找编程的灵感。我们可以发现组合模式存在着一下几个特点：</p><ol><li>叶子类和非叶子类都继承自同一个组合类</li><li>叶子类和非叶子类有针对性地继承组合父类的某些方法。</li></ol><p>接着尝试用组合模式解决我们的需求。假设将所有员工分为两类，领导和员工，领导有雇佣和开除员工的权限，而员工有执行具体任务的业务能力。首先新建公共父类，拥有员工和领导的所有方法。</p><pre><code>public class Component {    protected String name;    List&lt;Component&gt; subordinate;    public Component(String name){        this.name = name;        subordinate = new ArrayList&lt;&gt;();    }    public void add(Component c)//增加成员    {        throw new UnsupportedOperationException(&quot;该员工不支持此操作&quot;);    }    public void remove(Component c){ //删除成员        throw new UnsupportedOperationException(&quot;该员工不支持此操作&quot;);    }    public Component getChild(int i){ //获取成员        throw new UnsupportedOperationException(&quot;该员工不支持此操作&quot;);    }    public void operation(){  //业务方法        throw new UnsupportedOperationException(&quot;该员工不支持此操作&quot;);    }    public List&lt;Component&gt; getSubordinate() {        return subordinate;    }    @Override    public String toString() {        return name;    }    public void printAll(){        System.out.println(this);        for (Component employee : this.getSubordinate()) {            employee.printAll();        }    }}</code></pre><p>接着建立领导类和职员类</p><pre><code>public class Employer extends Component {    public Employer(String name){        super(name);    }    public void add(Component c)//增加成员    {        subordinate.add(c);    }    public void remove(Component c){ //删除成员        subordinate.remove(c);    }    public Component getChild(int i){ //获取成员        return subordinate.get(i);    }}public class Employee extends Component {    public Employee(String name){        super(name);    }    @Override    public void operation() {        System.out.println(&quot;员工执行业务操作&quot;);    }}</code></pre><p>最后我们就可以简单地实现访问所有的员工了</p><pre><code>public class Main {    public static void main(String[] agrs){        Employer CEO = new Employer(&quot;John&quot;);        Employer headSales = new Employer(&quot;Robert&quot;);        Employer headMarketing = new Employer(&quot;Michel&quot;);        Employee clerk1 = new Employee(&quot;Laura&quot;);        Employee clerk2 = new Employee(&quot;Bob&quot;);        Employee salesExecutive1 = new Employee(&quot;Richard&quot;);        Employee salesExecutive2 = new Employee(&quot;Rob&quot;);        CEO.add(headSales);        CEO.add(headMarketing);        headSales.add(salesExecutive1);        headSales.add(salesExecutive2);        headMarketing.add(clerk1);        headMarketing.add(clerk2);        //打印该组织的所有员工        CEO.printAll();    }}</code></pre><p>最后说一下组合模式的优缺点：</p><p>优点：</p><ol><li>高层模块调用简单，由于不管是树枝还是叶子，对于高层来说都是 Component，所以对调用者来说没有任何区别。</li><li>节点自由增减，从代码中可以看出，如果想要在某个节点下新增节点，只要找到父节点就好了，非常容易扩展，符合开闭原则，对以后的维护非常有利。</li></ol><p>缺点：</p><ol><li>设计复杂，客户端需要花更多时间理清类之间的层次关系。（这个是几乎所有设计模式所面临的问题）。</li><li>指向不明，由于对于调用者来说，并不清楚当前节点是树枝还是树叶。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/02/06/设计模式之组合模式/多重身份.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;组合模式（Composite）允许你将对象组合成树形结构来表现“整体/部分”层次结构。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="组合模式" scheme="https://dongxiawu.github.io/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>软件分析工具-understand</title>
    <link href="https://dongxiawu.github.io/2018/01/28/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-understand/"/>
    <id>https://dongxiawu.github.io/2018/01/28/软件分析工具-understand/</id>
    <published>2018-01-28T08:32:58.000Z</published>
    <updated>2018-05-04T08:20:23.527Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Read The Fucking Source Code.</p><footer><strong>Linus Benedict Torvalds</strong></footer></blockquote><img src="/2018/01/28/软件分析工具-understand/轻轻松松看源码.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><a id="more"></a><p>不知道各位平时有没有阅读系统源码或者项目的习惯，毕竟连 Linux 的创造者 —— Linus 老人家都鼓励我们多去阅读源码。但是一想到一些源码动辄上万行的代码量，真的有耐心一直坚持阅读的人又有多少呢？而且源码毕竟是别人写的，有时候只看源码想要理解作者的意图还是有点困难的。那么有没有什么办法能够提高我们阅读源码的速度，或者能够帮助我们理解作者的意图呢？</p><p>我们平时阅读源码的时候，一行一行地读肯定不是最有效的方式，总结一下我们阅读源码的目的主要有以下几点：</p><ol><li>了解功能实现方式</li><li>学习代码组织形式</li><li>在原有基础上增加功能</li></ol><p>再来看一下我们阅读源码的时候最希望知道的东西有什么</p><ol><li>这个类是干什么的，哪些类使用了这个类</li><li>这个方法是干什么的，它修改了那些变量</li><li>这个变量有什么用，哪个方法里修改了这个变量</li></ol><p>所以到这里我们可以推导出如何快速有效地阅读源码了</p><ol><li>阅读文档。读源码时阅读文档可以帮助我们了解这个库，类，方法等的功能和使用场景，能够是我们对源码有大致的了解。</li><li>阅读注释。优秀的源码必定带有大量的注释，通过注释我们可以了解类的实现原理、方法的功能等。</li><li>看类名，方法名，变量名等。好的源码可以用过变量名等就可以知道大概的作用，这也叫做“注释式编程”。</li><li>学习设计模式。绝大部分源码有运用了设计模式，设计模式也被称为开发人员的共同语言。了解设计模式能够让你快速地知道源码作者的意图和代码组织结构。</li></ol><p>以上说的都是一些我们阅读源码需要修炼的“硬功夫”，需要一步一个脚印地去学习，去进步。但是有一些工具却能够加快我们学习地脚步。比如一个叫做 Understand 的代码分析工具。</p><p>我们先来看看这个工具的效果。比如当我想看看这个类有哪些变量和方法时，它是这样的：<br><img src="/2018/01/28/软件分析工具-understand/UMLClassDiagram-okhttp3-OkHttpClient.png"></p><p>当我想看看某个方法被哪些方法调用了，它是这样的：<br><img src="/2018/01/28/软件分析工具-understand/ClusterCallButterfly-OkHttpClient-OkHttpClient.png"></p><p>当我想看看某个方法的工作流程，它是这样的：<br><img src="/2018/01/28/软件分析工具-understand/ControlFlow-OkHttpClient-OkHttpClient.png"></p><p>当我想看看某个方法的时序图时，它是这样的：<br><img src="/2018/01/28/软件分析工具-understand/UMLSequenceDiagram-OkHttpClient-OkHttpClient.png"></p><p>而且，我们可以通过点击图上的任意方法和类实现跳转，简直就是把代码变成流程图有木有。难怪 Understand 的宣传语就是“让你看代码一目十行”。</p><p>到这里，你应该知道 Understand 的作用了，Understand集成了代码编辑器，代码跟踪器和代码分析器，提供了很强大的界面，将分析结果以各种形式（图形、图表、架构图等）呈现给用户，能很大程度的方便程序员进行开发，维护，调试其代码。</p><p>Understand 有一下特点</p><ol><li>支持多语言：Ada, C, C++, C#, Java, FORTRAN, Delphi, Jovial, and PL/M ，混合语言的project也支持</li><li>多平台： Windows/Linux/Solaris/HP-UX/IRIX/MAC OS X</li><li>代码语法高亮、代码折迭、交叉跳转、书签等基本阅读功能。</li><li>可以对整个project的architecture、metrics进行分析并输出报表。</li><li>可以对代码生成多种图（butterfly graph、call graph、called by graph、control flow graph、UML class graph等），在图上点击节点可以跳转到对应的源代码位置。</li><li>提供Perl API便于扩展。作图全部是用Perl插件实现的，直接读取分析好的数据库作图。</li><li>内置的目录和文件比较器。</li><li>支持project的snapshot，并能和自家的TrackBack集成便于监视project的变化。</li></ol><p>看到这里，你是不是迫不及待地想试一下了呢？不过这个软件目前是收费的，而且安装包不能在官网下载到。必须发邮件去申请才能获取下载连接，而且回复时间也不固定，反正我发了一周还没有收到邮件，不过不用怕，在公众号后台回复 ”understand” 可以获取 Understand 的安装包、注册码和使用教程哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Read The Fucking Source Code.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Linus Benedict Torvalds&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;img src=&quot;/2018/01/28/软件分析工具-understand/轻轻松松看源码.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发工具" scheme="https://dongxiawu.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="软件分析工具" scheme="https://dongxiawu.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    
      <category term="understand" scheme="https://dongxiawu.github.io/tags/understand/"/>
    
  </entry>
  
  <entry>
    <title>Android无线调试</title>
    <link href="https://dongxiawu.github.io/2018/01/13/Android%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/"/>
    <id>https://dongxiawu.github.io/2018/01/13/Android无线调试/</id>
    <published>2018-01-13T12:41:48.000Z</published>
    <updated>2018-05-04T08:20:22.903Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/01/13/Android无线调试/ANDROID_WIFI_DEBUG.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>正常来说，我们在调试 Android 应用的时候都需要用 USB 数据线将 Android 设备和电脑连接。但是有的时候我们的应用需要通过 USB 来连接外设，或者担心 USB 接口松动，这个时候就可以使用使用 Android 无线调试功能。</p><a id="more"></a><h1 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h1><ul><li><p>手机打开 USB 调试功能</p><ol><li>找到 手机 -&gt; 设置 -&gt; 全部参数（关于手机） -&gt; 连续点击版本号5次即可进入开发者模式（不同设备位置有可能有细微差别）</li><li>找到 手机 -&gt; 设置 -&gt; 开发者选项 -&gt; 打开 USB 调试功能</li></ol><img src="/2018/01/13/Android无线调试/USB_DEBUG.png"></li><li><p>添加 adb 到环境变量</p><ul><li><p>windows</p><ol><li>我的电脑右键 -&gt; 属性 -&gt; 高级 -&gt; 环境变量</li></ol></li><li><p>linux</p><ol><li>在命令行终端输入 gedit ~/.bashrc</li><li>在文本最后添加： PATH=[Android Sdk Root]/platform-tools:$PATH，并保存退出，其中，[Android Sdk Root]是你Android Sdk 的目录</li><li>在命令行终端输入 source ~/.bashrc, 使环境变量生效（设置环境变量方法有多种，这里只是其中一种）</li></ol></li></ul></li><li><p>检查 adb 版本大于 v1.0.25</p><ul><li>在命令行终端 输入 adb –version 即可查看版本号，或者直接输入 adb，第一行即为版本号</li></ul></li><li><p>查看设备IP</p></li></ul><ul><li>将 Android 设备连接上 WIFI，并且和电脑处于同一路由下</li><li>点击 设置 -&gt; 关于手机 -&gt; 状态信息 -&gt; 找到设备IP</li></ul><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><ol><li><p>将 Android 手机用数据线连接到电脑（必须）</p></li><li><p>在命令行终端输入 adb tcpip <port>，其中 <port> 为端口号，可以任意指定，如：adb tcpip 5555</port></port></p></li><li><p>在命令行终端输入 adb connect <host>:<port>即可连接上 Android 手机，其中 <host>为 Android 手机ip，<port> 为端口号，adb connect 192.168.1.101:5555</port></host></port></host></p></li><li><p>当要断开连接时，在命令行终端输入adb disconnect <host>:<port>，如 adb disconnect 192.168.1.101:5555</port></host></p></li></ol><img src="/2018/01/13/Android无线调试/ANDROID_DEBUG.png"><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>如果觉得命令行的方式太麻烦，可以使用插件版本</p><ol><li><p>将 Android 手机用数据线连接到电脑（必须）</p></li><li><p>AndroidStudio -&gt; Settings -&gt; Plugin -&gt; Brouse repositories -&gt; ADB WIFI 安装插件（重启生效）</p></li><li><p>AndroidStudio -&gt; Tools -&gt; Android -&gt; ADB WIFI -&gt; ADB USB to WIFI</p></li></ol><img src="/2018/01/13/Android无线调试/ADB_WIFI.png"><p>参考资料：</p><p>[1] <a href="http://blog.csdn.net/daditao/article/details/19077281" target="_blank" rel="external">http://blog.csdn.net/daditao/article/details/19077281</a></p><p>[2] <a href="http://www.linuxidc.com/Linux/2015-08/121192.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2015-08/121192.htm</a></p><p>[3] <a href="http://blog.csdn.net/zxw2844/article/details/8560052" target="_blank" rel="external">http://blog.csdn.net/zxw2844/article/details/8560052</a></p><p>[4]<a href="http://blog.csdn.net/github_2011/article/details/70738203" target="_blank" rel="external">http://blog.csdn.net/github_2011/article/details/70738203</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/01/13/Android无线调试/ANDROID_WIFI_DEBUG.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正常来说，我们在调试 Android 应用的时候都需要用 USB 数据线将 Android 设备和电脑连接。但是有的时候我们的应用需要通过 USB 来连接外设，或者担心 USB 接口松动，这个时候就可以使用使用 Android 无线调试功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Android调试技巧" scheme="https://dongxiawu.github.io/categories/Android%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Android" scheme="https://dongxiawu.github.io/tags/Android/"/>
    
      <category term="无线调试" scheme="https://dongxiawu.github.io/tags/%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2017年度总结</title>
    <link href="https://dongxiawu.github.io/2017/12/31/2017%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://dongxiawu.github.io/2017/12/31/2017年度总结/</id>
    <published>2017-12-31T11:10:09.000Z</published>
    <updated>2018-05-04T08:20:22.367Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/31/2017年度总结/2018.png"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>2017年马上就要过去了，这一年，应该是我研究生阶段经历事情最多的一年了。</p><a id="more"></a><h1 id="找实习"><a href="#找实习" class="headerlink" title="找实习"></a>找实习</h1><p>从2017年过完年后，我便开始复习准备找实习了。中间剧情的跌宕起伏堪比电视连续剧。</p><p>先是第一次面试就面试网易游戏，结果一面就跪了。然后就来个人品大爆发，面试阿里连面4面。面到 HR 了，本来以为十拿九稳了，结果通知我面试没通过。接着就是学院第一批面试腾讯的，而且接到邀请去深圳总部面试，然而还是倒在了总监面。然后就连 90% 通过率的华为也挂了。</p><p>接下来就慌了，开始盲目的投简历，也不管公司规模和专业对不对口。结果5月初才拿到了第一个实习offer——4399，Unity 开发。</p><p>本来本着学习的心态去了 4399 实习，但是发现自己实在不喜欢游戏开发，过了两周我就决定辞职了。就在我刚刚提交离职申请的时候，事情发生了惊天大逆转：我收到了阿里的实习offer。</p><p>至次，我的找实习之旅终于结束了。</p><h1 id="实习中"><a href="#实习中" class="headerlink" title="实习中"></a>实习中</h1><p>从7月3号正式入职阿里，到9月5号坐上回家的飞机，中间经历了很多第一次。</p><p>第一次做飞机，是从广州白云机场到杭州萧山机场的。由于第一次坐飞机有点紧张。我提前了2个小时到机场，然后就在候机大厅坐了两个小时。</p><p>第一次和中介斗智斗勇。由于公司只提供两周的住宿。所以我们必须要自己租房子住。由于实习期间太短，很多人不愿意短租，甚至由于是租房高峰期，连空房子都很难找。结果在闲鱼上找到一间，还是中介挂出来的，8平米，还是阳台隔出来的，一个月1650，加上水电费1800多，没办法，只能硬着头皮租了下来。</p><p>中介嘴上说一套，实际做一套，实习快结束了才发现自己上当了。然后就开始和中介斗智斗勇，想方设法的想把押金要回来。结果还好，只损失了几百块。不过这个中介公司我以后再也不信了。</p><p>第一次接触实际项目。我在的部门是农村淘宝事业部，我们部门的 app 在我开始实习前几个月并入了手机淘宝，所以我后来都是在手机淘宝上做开发的。手机淘宝有5亿的用户，所以我现在可以说我开发的功能被5亿用户使用了！</p><p>第一次实习答辩。实习结束的时候每个人都有一次答辩，答辩结果直接决定能不能拿到offer。虽然事先准备了挺久了，也有小组内预答辩过，但是正式答辩那天还是挺紧张的。我答辩那天有3个总监级别的老大和 HR 一起面试。说实话，表现我个人觉得一般，所以能拿到 offer 我很感谢他们手下留情，哈哈。</p><p>第一次和爸妈去旅行。实习结束的时候，老爸老妈来杭州找我，我们一起去了上海，苏州和杭州逛了一圈。说到他们为什么最后会拗不过我选择出来玩，就是因为老爸觉得我拿不到阿里的转正offer的，不知道下次出来是什么时候了，所以才会决定出来玩。没想到他们来的第一天我就收到阿里的转正成功邮件，所以那几天我们玩得都挺开心的。</p><h1 id="校招中"><a href="#校招中" class="headerlink" title="校招中"></a>校招中</h1><p>我的校招在我坐上从杭州回家的飞机就开始了。</p><p>当时我刚上飞机，就接到了微信的面试电话，不过飞机快起飞了，就把面试推迟了，虽然结果也没通过。</p><p>在校招过程中，因为有了阿里的实习经历做背书，所以基本上还算比较顺利的，拿到了美团和网易游戏的offer，但是我最终还是选择了阿里，一个是因为我觉得部门的人很nice，而且相对比较自由，公司平台大，能够学到更多的东西，另外一个是因为我知道如果我没有阿里的实习和offer，我的校招之路不可能走得那么顺利。</p><p>既然别人都认可阿里，而且我刚好有这个机会，那我为什么不去试一下呢？</p><h1 id="毕业设计"><a href="#毕业设计" class="headerlink" title="毕业设计"></a>毕业设计</h1><p>校招结束之后，我又马不停蹄地开始了毕业设计，由于我毕业设计题目在5月份换过一次，所以我比别人的进度慢了一点。好在到目前为止已经基本做好了，可以开始毕业论文了。</p><h1 id="新年展望"><a href="#新年展望" class="headerlink" title="新年展望"></a>新年展望</h1><p>经历过找实习和工作之后，才发觉原来要进入社会也是如此艰辛。但是我觉得我是时候进入社会了。<br>希望在2018年里能够</p><ol><li>和女朋友早点结束异地</li><li>早点发专利，顺顺利利毕业</li><li>成为一个合格的程序员，不断进步</li><li>做好自己职业的发展规划</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/31/2017年度总结/2018.png&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2017年马上就要过去了，这一年，应该是我研究生阶段经历事情最多的一年了。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="https://dongxiawu.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="https://dongxiawu.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>FastCV Demo in Android Studio</title>
    <link href="https://dongxiawu.github.io/2017/12/25/FastCV%20Demo%20in%20Android%20Studio/"/>
    <id>https://dongxiawu.github.io/2017/12/25/FastCV Demo in Android Studio/</id>
    <published>2017-12-25T14:27:41.000Z</published>
    <updated>2018-05-04T08:20:23.348Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/25/FastCV%20Demo%20in%20Android%20Studio/FastCV.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>最近的项目需要在 Android 手机上进行摄像头视频采集、处理。所以需要使用上计算机视觉的库。一开始选择使用 OpenCV 开源库，具体使用参照我之前的文章<br><a href="https://dongxiawu.github.io/2017/12/14/AndroidStudio%E4%BD%BF%E7%94%A8OpenCV%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/">AndroidStudio使用OpenCV的三种方式</a></p><p>但是 OpenCV 的速度并不能达到要求，同时无意中发现了一个叫做 FastCV 的计算机视觉库，于是就想试一下。但是发现网络上几乎没有关于 FastCV 的 Demo 在 Android Studio 上成功编译的先例，于是只好利用 google、stackoverflow 和 FastCV 官网的自己自己尝试编译，踩了一些坑，最后终于搞定了。</p><p>虽然最终因为某些原因并没有使用 FastCV 的 SDK，但是相信这些经验会对一些人有帮助，所以在这里分享给大家。</p><a id="more"></a><p>FastCV 是一个计算机视觉函数库，可以看做的是迷你版的 OpenCV，是高通公司开发的基于高通芯片的 SDK，目前支持的操作系统有：</p><ul><li>Android</li><li>Linux</li><li>Windows RT</li><li>Windows Phone 8</li></ul><p>FastCV 最大的特点就是快，这是因为高通公司针对自己的芯片做了特别的优化的缘故。缺点也特别明显，就是 FastCV 是闭源的，只提供 API，并不提供源码，而且只能运行在高通的芯片上。</p><p>由于 FastCV 已经很久没有更新版本了，上一次更新是 16年3月，所以 FastCV 的 Demo 还是基于 eclipse 的，而且不能直接导入 Android Studio，所以需要移植。</p><p>关于 Android JNI 的构建方式，目前有 ndk-build 和 cmake 两种方式，谷歌推荐 cmake，本工程也采用cmake</p><p>开发环境: Android Studio3.0 + Ubuntu 16.04 LTS</p><h1 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h1><ol><li><p>首先在 FastCV 的官网上注册并下载 FastCV SDK<br><a href="https://developer.qualcomm.com/software/fastcv-sdk" target="_blank" rel="external">https://developer.qualcomm.com/software/fastcv-sdk</a></p></li><li><p>在下载目录下运行</p><p>2.1 修改文件权限</p><p><code>sudo chmod a+x fastcv-installer-android-1-7-1.bin</code></p><p>2.2 安装软件</p><p><code>sudo ./fastcv-installer-android-1-7-1.bin</code></p><p>注意，安装 FastCV SDK 需要电脑已经安装 JDK，并且目前还不支持 JDK9，如果你的电脑安装的是 JDK9，那么请记得先切换一下 JDK 版本</p></li></ol><h1 id="移植-FastCV-代码"><a href="#移植-FastCV-代码" class="headerlink" title="移植 FastCV 代码"></a>移植 FastCV 代码</h1><ol><li><p>新建 Android Studio 工程（我选择移植的是 fastcvdemo 工程，所以新建工程时包名可以仿照 fastcvdemo 工程包名，减少工作量）</p></li><li><p>将 fastcvdemo/jni 内头文件复制到 project root/app/src/main/cpp/include 文件夹下</p><p>将 fastcvdemo/jni 内源文件复制到 project root/app/src/main/cpp/source 文件夹下，</p><p>将 fastcvdemo/res 内文件复制到 project root/app/src/main/res 文件夹下</p><p>将 fastcvdemo/src 内文件复制到 project root/app/src/main/java 文件夹下</p><p>将 sdk root/lib/Android/lib64/libfastcv.a复制到 project root/app/src/main/jniLibs 文件夹下</p></li></ol><h1 id="编写-cmake-脚本"><a href="#编写-cmake-脚本" class="headerlink" title="编写 cmake 脚本"></a>编写 cmake 脚本</h1><p>为了让 Android Studio 能正确编译我们的程序，需要编写一个脚本告诉 Android Studio 我们的代码结构，这就是 cmake 的作用</p><ol><li><p>在 project root/app 目录下新建 CMakeLists.txt 文件，并添加以下内容:</p><blockquote><p>#指定 cmake 的最小版本，确保能使用某些新特性构建项目<br>   cmake_minimum_required(VERSION 3.4.1)</p><p>#输出详细信息<br>   set(CMAKE_VERBOSE_MAKEFILE on)</p><p>#设置头文件目录<br>   set(INCLUDE_DIR “${CMAKE_SOURCE_DIR}/src/main/cpp/include”)<br>   #设置源文件目录<br>   set(SOURCE_DIR “${CMAKE_SOURCE_DIR}/src/main/cpp/source”)<br>   #设置库目录<br>   set(LIBRARY_DIR “${CMAKE_SOURCE_DIR}/src/main/jniLibs”)</p><p>#包含头文件<br>   include_directories(${INCLUDE_DIR})</p><p>#添加 fastcv 静态库<br>   add_library(fastcv-lib STATIC IMPORTED)<br>   set_target_properties( fastcv-lib<br>   PROPERTIES IMPORTED_LOCATION<br>   “${LIBRARY_DIR}/libfastcv.a”)</p><p>#添加 log 库<br>   find_library( log-lib log )</p><p>find_path(GLES2_INCLUDE_DIR GLES2/gl2.h<br>   HINTS ${ANDROID_NDK})<br>   include_directories(${GLES2_INCLUDE_DIR})</p><p>find_library(GLES2_LIBRARY libGLESv2.so<br>   HINTS ${GLES2_INCLUDE_DIR}/../lib)</p><p>#包含子目录<br>   add_subdirectory(${SOURCE_DIR})</p></blockquote><p>由于 cmake 具有递归查找功能，所以要在每个包含的子目录下也新建 CMakeLists.txt 文件，具体添加内容查看 Demo</p></li><li><p>在app目录下的build.gradle 内添加：</p><pre><code>android {  defaultConfig {    ...    externalNativeBuild {        cmake {            arguments &quot;-DANDROID_ARM_NEON=TRUE&quot;,                    &quot;-DVAR_NAME=ARG_1 ARG_2&quot;,                    &quot;-DANDROID_CPP_FEATURES=rtti exceptions&quot;            cppFlags &quot;-std=c++11&quot;, &quot;-frtti&quot;, &quot;-fexceptions&quot;        }    }    ndk {        //只支持高通指令集        abiFilters &apos;arm64-v8a&apos;    }}externalNativeBuild {    cmake{        path &quot;CMakeLists.txt&quot;    }  }}</code></pre></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，就可以正常编译并运行 FastCV Demo 了，Demo 提供的各种图像处理操作都能达到实时性的效果，但是由于 FastCV SDK 的缺点很明显，只支持高通 CPU 和不开源，所以网上资料少也就不奇怪了。</p><p>关于FastCV Demo，我上传到了 github上，请自行下载。<br><a href="https://github.com/dongxiawu/FastcvDemo" target="_blank" rel="external">https://github.com/dongxiawu/FastcvDemo</a></p><p>参考资料：</p><p>[1] <a href="https://developer.qualcomm.com/software/fastcv-sdk" target="_blank" rel="external">https://developer.qualcomm.com/software/fastcv-sdk</a></p><p>[2] <a href="https://cmake.org/cmake-tutorial/" target="_blank" rel="external">https://cmake.org/cmake-tutorial/</a></p><p>[3] <a href="https://developer.android.google.cn/studio/projects/add-native-code.html?hl=zh-cn" target="_blank" rel="external">https://developer.android.google.cn/studio/projects/add-native-code.html?hl=zh-cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/25/FastCV%20Demo%20in%20Android%20Studio/FastCV.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近的项目需要在 Android 手机上进行摄像头视频采集、处理。所以需要使用上计算机视觉的库。一开始选择使用 OpenCV 开源库，具体使用参照我之前的文章&lt;br&gt;&lt;a href=&quot;https://dongxiawu.github.io/2017/12/14/AndroidStudio%E4%BD%BF%E7%94%A8OpenCV%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/&quot;&gt;AndroidStudio使用OpenCV的三种方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是 OpenCV 的速度并不能达到要求，同时无意中发现了一个叫做 FastCV 的计算机视觉库，于是就想试一下。但是发现网络上几乎没有关于 FastCV 的 Demo 在 Android Studio 上成功编译的先例，于是只好利用 google、stackoverflow 和 FastCV 官网的自己自己尝试编译，踩了一些坑，最后终于搞定了。&lt;/p&gt;
&lt;p&gt;虽然最终因为某些原因并没有使用 FastCV 的 SDK，但是相信这些经验会对一些人有帮助，所以在这里分享给大家。&lt;/p&gt;
    
    </summary>
    
      <category term="FastCV" scheme="https://dongxiawu.github.io/categories/FastCV/"/>
    
    
      <category term="Android" scheme="https://dongxiawu.github.io/tags/Android/"/>
    
      <category term="FastCV" scheme="https://dongxiawu.github.io/tags/FastCV/"/>
    
      <category term="JNI" scheme="https://dongxiawu.github.io/tags/JNI/"/>
    
      <category term="cmake" scheme="https://dongxiawu.github.io/tags/cmake/"/>
    
      <category term="Android Studio" scheme="https://dongxiawu.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio使用OpenCV的三种方式</title>
    <link href="https://dongxiawu.github.io/2017/12/14/AndroidStudio%E4%BD%BF%E7%94%A8OpenCV%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://dongxiawu.github.io/2017/12/14/AndroidStudio使用OpenCV的三种方式/</id>
    <published>2017-12-14T02:08:07.000Z</published>
    <updated>2018-05-04T08:20:22.367Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/14/AndroidStudio使用OpenCV的三种方式/AndroidStudio使用OpenCV的三种方式.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>最近的项目需要在 Android 手机上使用 OpenCV 开源库，于是到网上找教程。没想到网上的教程大多数是 eclipse 的，还有很多是错的，最后还是靠 Stack Overflow、 OpenCV 官网和 Google 解决了这个问题，在这里记录一下，希望能帮到有需要的人。</p><p>要在 Android 上使用 OpenCV，总体上来说有三种方法</p><ol><li>使用 OpenCV Manager + OpenCV Android SDK</li><li>使用 OpenCV Android SDK + OpenCV 动态库</li><li>使用 OpenCV 动态库 + JNI</li></ol><p>开发环境: Android Studio3.0 + Ubuntu 16.04 LTS</p><a id="more"></a><h2 id="使用-OpenCV-Manager-OpenCV-Android-SDK"><a href="#使用-OpenCV-Manager-OpenCV-Android-SDK" class="headerlink" title="使用 OpenCV Manager + OpenCV Android SDK"></a>使用 OpenCV Manager + OpenCV Android SDK</h2><p>这种方法最简单，但是也对用户最不友好，因为需要多安装 OpenCV Manager 这个APK，适合在快速验证功能的时候使用。</p><p>其实这种方法的原理就是利用 Android 的 Service 来进行跨进程通信，主要流程如下：</p><p>具体操作步骤如下：</p><ol><li><p>新建 Android 工程</p></li><li><p>下载 OpenCV-Android-SDK，下载地址: <a href="https://opencv.org/releases.html" target="_blank" rel="external">https://opencv.org/releases.html</a></p></li><li><p>点击 File -&gt; new -&gt; Import Module, 选中 OpenCV-Android-SDK/sdk/java 文件夹,点击确定，就会自动识别处模块，如下图所示：</p><img src="/2017/12/14/AndroidStudio使用OpenCV的三种方式/导入OpenCV.png"><p>导入完成后，会在工程目录下发现 OpenCV 的库，settings.gradle 文件也会相应改变</p></li><li><p>点击 File -&gt; Project Structure，在 Modules 下点击 依赖 OpenCV 的模块（比如 app ），再点击右边的 Dependencies。点击右侧加号选第三个 Module dependency 后选择 openCVLibrary310 后点击完成。</p><img src="/2017/12/14/AndroidStudio使用OpenCV的三种方式/添加opencv依赖.png"><p>完成后会发现 app目录下的 build.gradle 中的 dependencies 增加了 oepncv 的依赖。<br>到这里，我们就可以在程序里面使用 OpenCV 的类了。</p></li><li><p>由于 OpenCV 库的版本一般情况下和你的工程的版本号不同，所以需要把 OpenCV 库目录下的 build.gradle 中的编译版本，构建版本等参数设置成和工程一样。</p></li><li><p>根据手机安装对应的 OpenCV Manager apk，apk 在 OpenCV-Android-SDK/apk 目录下。可以将 apk 复制到手机内存卡里安装，也可以将手机连上电脑，然后通过命令行安装，安装命令：adb install [OpenCV_xxx.apk]</p></li><li><p>在使用 OpenCV 功能前 使用<br>OpenCVLoader.initAsync(String Version, Context AppContext,<br>LoaderCallbackInterface Callback) 这个方法进行初始化，初始化成功之后就可以正常使用 OpenCV 库了。</p></li></ol><h2 id="使用-OpenCV-Android-SDK-OpenCV-动态库"><a href="#使用-OpenCV-Android-SDK-OpenCV-动态库" class="headerlink" title="使用 OpenCV Android SDK + OpenCV 动态库"></a>使用 OpenCV Android SDK + OpenCV 动态库</h2><p>第一种方法有点就是简单，缺点就是必须要安装 OpenCV Manager apk。要用户同时安装两个 apk 并不太现实，所以第一种方法不适合在实际项目中使用。而采用 OpenCV Android SDK + OpenCV 动态库 的方法就可以避免这个问题。</p><p>主要步骤（1-5点都和之前一样）：</p><ol><li><p>新建 Android 工程</p></li><li><p>下载 OpenCV-Android-SDK，下载地址: <a href="https://opencv.org/releases.html" target="_blank" rel="external">https://opencv.org/releases.html</a></p></li><li><p>点击 File -&gt; new -&gt; Import Module, 选中 OpenCV-Android-SDK/sdk/java 文件夹,点击确定，就会自动识别处模块，如下图所示：</p><img src="/2017/12/14/AndroidStudio使用OpenCV的三种方式/导入OpenCV.png"><p>导入完成后，会在工程目录下发现 OpenCV 的库，settings.gradle 文件也会相应改变</p></li><li><p>点击 File -&gt; Project Structure，在 Modules 下点击 依赖 OpenCV 的模块（比如 app ），再点击右边的 Dependencies。点击右侧加号选第三个 Module dependency 后选择 openCVLibrary310 后点击完成。</p><img src="/2017/12/14/AndroidStudio使用OpenCV的三种方式/添加opencv依赖.png"><p>完成后会发现 app目录下的 build.gradle 中的 dependencies 增加了 oepncv 的依赖。<br>到这里，我们就可以在程序里面使用 OpenCV 的类了。</p></li><li><p>由于 OpenCV 库的版本一般情况下和你的工程的版本号不同，所以需要把 OpenCV 库目录下的 build.gradle 中的编译版本，构建版本等参数设置成和工程一样</p></li><li><p>将 OpenCV-Android-SDK/sdk/native/libs 目录下全部内容复制到 工程目录/app/src/main/jniLibs 目录下（这里可以针对特定的手机做裁剪，为了方便可以全部复制）</p></li><li><p>在使用 OpenCV 功能前 使用下面代码加载 OpenCV 动态库</p><pre><code>static {    System.loadLibrary(&quot;opencv_java3&quot;);}</code></pre><p>然后使用</p><pre><code>OpenCVLoader.initDebug();</code></pre><p>进行初始化。初始化成功之后，就可以正常使用 OpenCV 进行开发了。</p></li></ol><h2 id="使用-OpenCV-动态库-JNI"><a href="#使用-OpenCV-动态库-JNI" class="headerlink" title="使用 OpenCV 动态库 + JNI"></a>使用 OpenCV 动态库 + JNI</h2><p>第二种方法由于不需要安装 OpenCV Manager，同时又是使用 OpenCV Android SDK 在 Java 层进行开发，故开发速度非常快，十分适合一般的引用场景。但该方法也有几个缺点：</p><ol><li>使用 OpenCV Android SDK 会增大 APK 的体积。</li><li>由于在 Java 层进行开发，在某些场景下会导致运行效率不高。</li></ol><p>因此引出了第三中方法。该方法使用 OpenCV 动态库 + JNI 的方式进行开发，适合在对计算效率要求比较高的场景下使用。，但由于采用了 JNI（Java Native Interface）技术，开发的难度也是最大的。</p><p>主要步骤：</p><ol><li><p>新建 Android 工程</p></li><li><p>下载 OpenCV-Android-SDK，下载地址: <a href="https://opencv.org/releases.html" target="_blank" rel="external">https://opencv.org/releases.html</a></p></li><li><p>下载相关工具</p><p>3.1 在打开的项目中，从菜单栏选择 Tools -&gt; Android -&gt; SDK Manager。</p><p>3.2 点击 SDK Tools 标签。</p><p>3.3 选中 LLDB、CMake 和 NDK 旁的复选框，如下图所示。</p><img src="/2017/12/14/AndroidStudio使用OpenCV的三种方式/JNI相关工具.png"></li><li><p>将 OpenCV-Android-SDK/sdk/native/libs 目录下全部内容复制到 工程目录/app/src/main/jniLibs 目录下（这里可以针对特定的手机做裁剪，为了方便可以全部复制）</p></li><li><p>创建新的原生源文件</p><p>要在应用模块的主源代码集中创建一个包含新建原生源文件的 cpp/ 目录，并新建 source 和 include 的子目录。在 source 目录下新建源文件 native-lib.cpp</p></li><li><p>复制头文件</p><p> 将 OpenCV-Android-SDK/sdk/native/jni/include 目录下全部内容复制到 工程目录/app/src/main/cpp/include 目录下</p></li><li><p>编辑 CMakeLists.txt</p><p>在模块根目录下新建文件 CMakeLists.txt，并添加以下内容：</p><blockquote><p>#指定 cmake 的最小版本，确保能使用某些新特性构建项目<br>cmake_minimum_required(VERSION 3.4.1)</p><p>#输出详细信息<br>set(CMAKE_VERBOSE_MAKEFILE on)</p><p>#设置库目录<br>set(LIBRARY_DIRS “${CMAKE_SOURCE_DIR}/src/main/jniLibs”)</p><p>#包含头文件目录<br>include_directories(src/main/cpp/include)</p><p>#添加 opencv 的动态库</p><p>add_library( libopencv_java3 SHARED IMPORTED )</p><p>#指定库路径</p><p>set_target_properties( libopencv_java3 IMPORTED_LOCATION “${LIBRARY_DIRS}/${ANDROID_ABI}/libopencv_java3.so” )</p><p>#设置源文件目录<br>aux_source_directory(src/main/cpp/source SOURCE_DIR)</p><p>add_library( native-lib SHARED ${SOURCE_DIR} )</p><p>find_library( log-lib log )</p><p>target_link_libraries( native-lib libopencv_java3 ${log-lib} )</p></blockquote></li><li><p>修改 build.gradle<br>在模块的 build.gradle 内的 android 闭包内添加：</p><pre><code>// Encapsulates your external native build configurations.externalNativeBuild {    // Encapsulates your CMake build configurations.    cmake {        // Provides a relative path to your CMake build script.        path &quot;CMakeLists.txt&quot;    }}</code></pre></li><li><p>编写 JNI 接口和 C++ 代码。</p><p>上面 CMakeLists.txt 的作用是将 opencv 的动态库和 native-lib.cpp 链接起来生成新的动态库。</p><p>到目前位置，我们已经能够在 native-lib.cpp 内使用 C++ 编写 OpenCV 程序了。</p><p>接下来的步骤为：</p><ol><li>在 Java 层编写 native 方法</li><li>使用 javah -jni 生成本地接口</li><li>在 C++ 层实现接口</li><li>在 Java 层调用 native 方法。</li></ol><p>由于这部分是普通的 JNI 使用，不属于 opencv 的内容，所以不在这里展开了。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，就介绍了 Android 使用 OepnCV 的三种方式。其中我个人推荐第二种方法。</p><p>关于第三种方法，我采用的是 cmake 构建，虽然也可以采用 ndk 的方式，但是我个人推荐的是 cmake，因为 cmake 更加简单，应用范围也更广泛，谷歌目前推荐的构建方式也是 cmake。</p><p>关于三种方法的 Demo，我上传到了 github上，请自行下载。<br><a href="https://github.com/dongxiawu/OpencvDemo" target="_blank" rel="external">https://github.com/dongxiawu/OpencvDemo</a></p><p>参考资料：</p><p>[1] <a href="https://www.cnblogs.com/yunfang/p/6149831.html" target="_blank" rel="external">https://www.cnblogs.com/yunfang/p/6149831.html</a></p><p>[2] <a href="https://docs.opencv.org/2.4/doc/tutorials/introduction/android_binary_package/dev_with_OCV_on_Android.html" target="_blank" rel="external">https://docs.opencv.org/2.4/doc/tutorials/introduction/android_binary_package/dev_with_OCV_on_Android.html</a></p><p>[3] <a href="https://docs.opencv.org/2.4.13.4/platforms/android/service/doc/UseCases.html#first-application-start" target="_blank" rel="external">https://docs.opencv.org/2.4.13.4/platforms/android/service/doc/UseCases.html#first-application-start</a></p><p>[4] <a href="https://developer.android.google.cn/studio/projects/add-native-code.html?hl=zh-cn" target="_blank" rel="external">https://developer.android.google.cn/studio/projects/add-native-code.html?hl=zh-cn</a></p><p>[5] <a href="https://cmake.org/cmake/help/v3.10/" target="_blank" rel="external">https://cmake.org/cmake/help/v3.10/</a></p><p>[6] <a href="http://blog.csdn.net/Jason101123/article/details/78600355" target="_blank" rel="external">http://blog.csdn.net/Jason101123/article/details/78600355</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/14/AndroidStudio使用OpenCV的三种方式/AndroidStudio使用OpenCV的三种方式.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近的项目需要在 Android 手机上使用 OpenCV 开源库，于是到网上找教程。没想到网上的教程大多数是 eclipse 的，还有很多是错的，最后还是靠 Stack Overflow、 OpenCV 官网和 Google 解决了这个问题，在这里记录一下，希望能帮到有需要的人。&lt;/p&gt;
&lt;p&gt;要在 Android 上使用 OpenCV，总体上来说有三种方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 OpenCV Manager + OpenCV Android SDK&lt;/li&gt;
&lt;li&gt;使用 OpenCV Android SDK + OpenCV 动态库&lt;/li&gt;
&lt;li&gt;使用 OpenCV 动态库 + JNI&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;开发环境: Android Studio3.0 + Ubuntu 16.04 LTS&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="https://dongxiawu.github.io/categories/OpenCV/"/>
    
    
      <category term="Android" scheme="https://dongxiawu.github.io/tags/Android/"/>
    
      <category term="JNI" scheme="https://dongxiawu.github.io/tags/JNI/"/>
    
      <category term="cmake" scheme="https://dongxiawu.github.io/tags/cmake/"/>
    
      <category term="Android Studio" scheme="https://dongxiawu.github.io/tags/Android-Studio/"/>
    
      <category term="OpenCV" scheme="https://dongxiawu.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之生成器模式</title>
    <link href="https://dongxiawu.github.io/2017/12/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongxiawu.github.io/2017/12/09/设计模式之生成器模式/</id>
    <published>2017-12-09T11:10:21.000Z</published>
    <updated>2018-05-04T08:20:23.519Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/09/设计模式之生成器模式/玛尼玛尼哄.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>生成器模式（Builder）模式，封装一个产品的构造过程，并允许按步骤构造。</p><a id="more"></a><p>生成器模式是日常开发中使用最广的设计模式之一，几乎可以说每个稍微大一点的项目都会用到生成器模式。比如 Android 源码的 AlertDialog，最流行的网络库之一 okhttp 等等。</p><p>首先我们看一下生成器模式的 UML 图</p><img src="/2017/12/09/设计模式之生成器模式/生成器模式.png"><p>生成器模式主要有以下几个优点：</p><ol><li>将一个复杂对象用创建过程封装起来。</li><li>允许对象通过多个步骤来创建，并且可以改变过程。</li><li>向客户隐藏产品内部表现。</li><li>产品的实现可以替换。</li></ol><p>下面我通过一个简单的例子来讲解一下生成器模式的使用过程和优点。</p><p>假设我们要创建一个 Pizza 类，这个 Pizza 类有很多参数，比如尺寸，馅料种类，是否切块等。那么就存在这样的问题，如果我们把所有的参数都写在构造函数里，那么构造函数就会非常长，而且如果我们以后想要添加其他参数的话，改起来也会比较麻烦。还有一种方法就是先创建出 Pizza 对象，然后再用 setter 方法设置参数，但是这样有可能会导致有一些参数忘记设置了，并且这种方法会导致线程安全的问题。这个时候我们就可以使用生成器模式了。</p><p>代码如下：</p><pre><code>public class Pizza {int size = 0;int type = 0;boolean isDiced = false;private Pizza(){}protected void setSize(int size){    this.size = size;}protected void setStuffType(int type){    this.type = type;}protected void isDiced(boolean isDiced){    this.isDiced = isDiced;}public static class Builder{    int size = 0;    int type = 0;    boolean isDiced = false;    public Builder(){    }    public Builder setSize(int size){        this.size = size;        return this;    }    public Builder setStuffType(int type){        this.type = type;        return this;    }    public Builder isDiced(boolean isDiced){        this.isDiced = isDiced;        return this;    }    public Pizza build(){        Pizza pizza = new Pizza();        pizza.setSize(size);        pizza.setStuffType(type);        pizza.isDiced(isDiced);        return pizza;    }  }}</code></pre><p>从代码里我们可以看出几个特点</p><ol><li>Pizza 类的构造函数是私有的，也就是说我们不能直接 new 出一个 Pizza 对象，只能通过 Builder 类的 build 方法构建出 Pizza 对象。</li><li>Builder 类是 Pizza 类的 静态内部类，也就是说我们可以直接创建出 Builder 对象，而不用先创建出 Pizza 对象。</li><li>Builder 类的大部分 setter 方法都和 Pizza 类的 setter 方法一样，但是 Builder 类的 setter 方法是 public 的，而 Pizza 的 setter 方法一般是 private 或者 protected 的。</li><li>在 Builder 对象的 build 方法被调用时才真正生成 Pizza 对象。我们可以在 build 方法里做一些控制，比如参数合法性检测，必填参数检测等。</li><li>Builder 类的参数和 Pizza 类的参数是一样的，这样无形之中增加了代码的复杂度，也增加了出错的可能行。不过我们可以通过另外的一个参数类 Params 来存放所有参数，具体可以看 Android 源码的 AlertDialog 类。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/09/设计模式之生成器模式/玛尼玛尼哄.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生成器模式（Builder）模式，封装一个产品的构造过程，并允许按步骤构造。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="生成器模式" scheme="https://dongxiawu.github.io/tags/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="https://dongxiawu.github.io/2017/12/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongxiawu.github.io/2017/12/09/设计模式之适配器模式/</id>
    <published>2017-12-09T11:10:11.000Z</published>
    <updated>2017-12-30T03:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/09/设计模式之适配器模式/适配器模式.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>适配器模式（Adapter）是我们在开发过程中经常会用到的一个设计模式。它的作用是将一个类的接口，转换另一个接口。</p><a id="more"></a><p>那么为什么要进行转换呢？想想生活的例子你就知道了。设想一下，你出国旅游，发现你的手机的充电器不能插进当地的插座，因为标准不同。这时候你会买一个转接器，然后解决了这个问题。这个转接器就是适配器，适配器模式也就是为了解决这一类问题而存在的。</p><p>我们回想一下转接器的工作原理：转接器一般由两面组成，一面是适配你的手机充电器插头的插座，另一面是适配当地插座的插头。你将你的手机充电器插进转接器，再将转接器插进当地的插座，就完成了适配。</p><p>设配器模式UML图如下：<br><img src="/2017/12/09/设计模式之适配器模式/适配器模式UML.png"></p><p>由此我们可以总结一下适配器模式的要点：</p><ol><li>适配器将一个对象包装起来以改变其接口以符合用户要求。</li></ol><p>那么我们如何用代码的形式实现适配器模式呢？假设我们现在有这么一个情景：现在手头上有一个遥控，上面有“上”和“下”两个按钮，但是我们希望用它来控制一个风扇的开关，这样就有了一个从“上”和“下”到“开”和“关”的转换。这种情况下就可以用到适配器模式了。</p><p>首先是风扇类，非常简单，有 on 和 off 两个方法</p><pre><code>public class Fan {    public void on(){        System.out.println(&quot;The fan is on&quot;);    }    public void off(){        System.out.println(&quot;The fan is off&quot;);    }}</code></pre><p>接着是遥控类，也非常简单，有 up 和 down 两个 方法</p><pre><code>public class Controler {    public void up(){        System.out.println(&quot;The up button is pressed&quot;);    }    public void down(){        System.out.println(&quot;The down button is pressed&quot;);    }}</code></pre><p>接着就是我们的适配器接口，上面和风扇一样有 on 和 off 两个方法。</p><pre><code>public interface Adapter {    void on();    void off();}</code></pre><p>接下来，我们把遥控和适配器组合起来，变成了风扇遥控器，按下 up 按钮就是风扇开，按下 down 按钮就是风扇关。</p><pre><code>public class FanControler extends Controler implements Adapter {    private Fan mFan;    public FanControler(Fan fan){        mFan = fan;    }    @Override    public void up() {        on();    }    @Override    public void down() {        off();    }    @Override    public void on() {        mFan.on();    }    @Override    public void off() {        mFan.off();    }}</code></pre><p>接下来我们就可以运行起来了：</p><pre><code>public class Main {    public static void main(String[] agrs){        Fan fan = new Fan();        Controler fanControler = new FanControler(fan);        fanControler.up();        fanControler.down();    }}</code></pre><p>运行结果如下：</p><pre><code>The fan is onThe fan is off</code></pre><p>由此可见，我们成功地将只有上和下两个按钮的遥控转换成了能够控制风扇开关的遥控器。</p><p>总结一下：</p><p>适配器模式能够将一个接口转换成另一个接口。具体是通过实现待转换的接口，同时持有目标接口，在内部进行接口转换实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/09/设计模式之适配器模式/适配器模式.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;适配器模式（Adapter）是我们在开发过程中经常会用到的一个设计模式。它的作用是将一个类的接口，转换另一个接口。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="https://dongxiawu.github.io/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="https://dongxiawu.github.io/2017/12/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongxiawu.github.io/2017/12/09/设计模式之策略模式/</id>
    <published>2017-12-09T10:43:11.000Z</published>
    <updated>2018-05-04T08:20:23.521Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/09/设计模式之策略模式/魂斗罗.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>策略模式（Strategy）：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p><a id="more"></a><p>相信我们很多人小时候都玩过一款叫做「 魂斗罗 」的游戏吧。在游戏里，人物可以获取不同的武器，从而打出不同类型、威力的子弹。那么，这在程序上是如何设计的呢？</p><p>首先想到的可能是可以用 <code>if-else</code> 或者 <code>switch</code> 的方式，列出所有可能的武器类型，比如下面的例子。</p><pre><code>public class Soldier {    private int gunType = -1;    public static final int PISTOL = 1;    public static final int RIFLE = 2;    public void setGunType(int gunType) {        this.gunType = gunType;    }    public int getGunType() {        return gunType;    }    public void shoot(){        switch (gunType){            case PISTOL:                System.out.println(&quot;射出手枪子弹&quot;);                break;            case RIFLE:                System.out.println(&quot;射出步枪子弹&quot;);                break;            default:break;        }    }}public class Main {    public static void main(String[] args) {    // write your code here        Soldier soldier = new Soldier();        soldier.setGunType(Soldier.PISTOL);        soldier.shoot();        soldier.setGunType(Soldier.RIFLE);        soldier.shoot();    }}</code></pre><p>输出的结果为：</p><pre><code>射出手枪子弹射出步枪子弹</code></pre><p>这种办法最大的缺点就是每次要新增或者要删除一种武器的时候，都要对士兵类进行修改，这就违背了「 <em>对扩展开发，对修改关闭</em> 」的设计原则。</p><p>其实遇到这种类型的问题，我们可以用「 策略模式 」解决。UML类图如下：</p><img src="/2017/12/09/设计模式之策略模式/策略模式UML.jpg"><p>那么用策略模式解决上面的「 魂斗罗 」问题，代码如下：</p><pre><code>public class Soldier {    private Gun gun;    public void setGun(Gun gun) {        this.gun = gun;    }    public Gun getGun() {        return gun;    }    public void shoot(){        if (gun != null){            gun.fire();        }    }}public interface Gun {    void fire();}public class Rifle implements Gun {    @Override    public void fire() {        System.out.println(&quot;射出步枪子弹&quot;);    }}public class Pistol implements Gun {    @Override    public void fire() {        System.out.println(&quot;射出手枪子弹&quot;);    }}public class Main {    public static void main(String[] args) {    // write your code here        Soldier soldier = new Soldier();        Gun pistol = new Pistol();        Gun rifle = new Rifle();        soldier.setGun(pistol);        soldier.shoot();        soldier.setGun(rifle);        soldier.shoot();    }}</code></pre><p>主要思路就是将 <em>枪支</em> 独立出来成为一个接口，每种类型的枪都实现这个接口，<em>士兵</em> 类持有枪支接口，并将具体的操作委托给枪支接口。</p><p>由此我们可以总结出「 策略模式 」一个很重要的特点就是：<em>把变化的部分抽离出来</em>。这实际上也是很多设计模式的指导思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/09/设计模式之策略模式/魂斗罗.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;策略模式（Strategy）：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="https://dongxiawu.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="https://dongxiawu.github.io/2017/11/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongxiawu.github.io/2017/11/25/设计模式之观察者模式/</id>
    <published>2017-11-25T12:45:37.000Z</published>
    <updated>2018-05-04T08:20:23.523Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/11/25/设计模式之观察者模式/暗中观察.jpg"><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><p>观察者模式（Observer）又称为发布-订阅（Publish-Subscribe）模式，它定义了对象之间一对多的依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p><a id="more"></a><p>观察者模式是日常开发中使用最广的设计模式之一，有许多开源库也用到了观察者模式，比如说： Rxjava，EventBus 等等。</p><img src="/2017/11/25/设计模式之观察者模式/观察者模式UML.png"><p>观察者模式主要有以下几个特点：</p><ol><li>观察者模式定义了对象之间一对多的关系</li><li>观察者和被观察者之间用松耦合的方式</li><li>观察者接收通知有两种方式，推和拉（推被认为更加正确）</li></ol><p>那么怎么使用观察者模式呢？举一个例子</p><p>目前很火的微信公众号相信大家都不陌生，当我们关注了某一个公众号的之后，每当公众号有新文章的时候，我们都会自动接收到更新。但是公众号博主并不需要知道关注他公众号的每一个人究竟是谁。当我们想看这个公众号更多的文章时候，还可以点击「 历史文章 」进行查看。当我们取消对某一个公众号的关注之后，不管这个公众号以后有多少文章更新，我们都不会再收到了，除非我们再次关注这个公众号。</p><p>这个公众号的例子就是一个典型的观察者模式的应用实例。从这个例子里我们可以总结出观察者模式的使用流程。</p><ol><li>注册（当我们关注了某个公众号的时候，实际上就是完成了注册的流程，我们告诉了该公众号「 我关注了你，以后你有新文章记得推送给我 」。）</li><li>通知（当我们接收到该公众号的新文章的时候，实际上就是完成了通知的流程，公众号告诉了我们「 我新发表了一篇文章，记得查收哦 」。）</li><li>拉取（当我们想查看该公众号更多的文章，点击了「历史文章」或其他按钮的时候，实际上就是完成了拉取的过程，我们告诉了该公众号「 我想看你其他的文章，你把链接发给我一下 」。）</li><li>解注册（当我们取消对某个公众号的关注的时候，实际上就是完成了解注册的流程，我们告诉了该公众号「 我不想再看你写的文章了，你以后都别推送给我了 」。）</li></ol><p>接下来，我们通过一个简单的例子实现一下观察者模式</p><pre><code>public interface Observer {void update(Observerable observerable, Object obj);}public interface Observerable {    void addObserver(Observer observer);    void removeObserver(Observer observer);    void notifyObservers();}public class Publisher implements Observerable {    private String publisherName;    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();    private List&lt;String&gt; articles = new ArrayList&lt;&gt;();    private String latestArticle = null;    public Publisher(@NotNull String name){        publisherName = name;    }    public String getPublisherName() {        return publisherName;    }    @Override    public void addObserver(Observer observer) {        if (!observers.contains(observer)){            observers.add(observer);        }    }    @Override    public void removeObserver(Observer observer) {        if (observers.contains(observer)){            observers.remove(observer);        }    }    @Override    public void notifyObservers() {        for (Observer observer : observers){            observer.update(this,latestArticle);        }    }    public void addNewArticle(String articleName){        articles.add(articleName);        latestArticle = articleName;        notifyObservers();    }    public List&lt;String&gt; getArticleList(){        return articles;    }}public class Reader implements Observer {    private String readerName;    List&lt;Publisher&gt; publishers = new ArrayList&lt;&gt;();    public Reader(@NotNull String name){        readerName = name;    }    public void follow(Publisher publisher){        if (!publishers.contains(publisher)){            publishers.add(publisher);            publisher.addObserver(this);            System.out.println(&quot;读者：　&quot; + readerName +                    &quot;　关注公众号：&quot; + publisher.getPublisherName());        }    }    public void unfollow(Publisher publisher){        if (publishers.contains(publisher)){            publishers.remove(publisher);            publisher.removeObserver(this);            System.out.println(&quot;读者：　&quot; + readerName +                    &quot;　取消关注公众号：&quot; + publisher.getPublisherName());        }    }    @Override    public void update(Observerable observerable, Object obj) {        System.out.println(&quot;读者：　&quot; + readerName                + &quot; 接收到公众号: &quot; + ((Publisher)observerable).getPublisherName()                + &quot;的新文章： &quot; + (String)obj);    }    public void getAllArticleByPublisher(Publisher publisher){        if (publishers.contains(publisher)){            publisher.getArticleList();            System.out.println(&quot;读者：　&quot; + readerName                    + &quot; 获取公众号: &quot; + publisher.getPublisherName()                    + &quot;的所有文章&quot;);        }else {            System.out.println(&quot;没有关注该公众号&quot;);        }    }}public class Test {    public static void main(String[] args){        Publisher publisherA = new Publisher(&quot;公众号１&quot;);        Publisher publisherB = new Publisher(&quot;公众号２&quot;);        Reader readerA = new Reader(&quot;读者１&quot;);        Reader readerB = new Reader(&quot;读者２&quot;);        readerA.follow(publisherA);        publisherA.addNewArticle(&quot;设计模式之观察者模式&quot;);        readerB.follow(publisherA);        publisherA.addNewArticle(&quot;设计模式之单例模式&quot;);        publisherB.addNewArticle(&quot;设计模式之策略模式&quot;);        readerA.follow(publisherB);        readerA.unfollow(publisherA);        readerA.getAllArticleByPublisher(publisherA);        readerA.getAllArticleByPublisher(publisherB);    }}</code></pre><p>通过上面的代码，我们就可以模拟出公众号和读者的关注，推送，获取，取消关注四个操作。</p><p>上面的代码执行结果为：</p><pre><code>读者：　读者１　关注公众号：公众号１读者：　读者１ 接收到公众号: 公众号１的新文章： 设计模式之观察者模式读者：　读者２　关注公众号：公众号１读者：　读者１ 接收到公众号: 公众号１的新文章： 设计模式之单例模式读者：　读者２ 接收到公众号: 公众号１的新文章： 设计模式之单例模式读者：　读者１　关注公众号：公众号２读者：　读者１　取消关注公众号：公众号１没有关注该公众号读者：　读者１ 获取公众号: 公众号２的所有文章</code></pre><p>那么什么时候就应该使用观察者模式呢？</p><ol><li>当一个模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</li><li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</li></ol><p>最后提一点，其实 Java 源码中的 「 java.util.Observer 」和 「 java.util.Observable 」 两个类就帮我们实现了观察者模式，但是有一点不同的是，「 java.util.Observable 」是类而不是接口，而 Java 的单继承机制就导致我们不能在继承「 java.util.Observable 」的时候同时又继承别的类。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/11/25/设计模式之观察者模式/暗中观察.jpg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为 &lt;em&gt;冬夏&lt;/em&gt; 原创文章，可以随意转载，但请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;观察者模式（Observer）又称为发布-订阅（Publish-Subscribe）模式，它定义了对象之间一对多的依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="https://dongxiawu.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://dongxiawu.github.io/2017/11/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongxiawu.github.io/2017/11/18/设计模式之单例模式/</id>
    <published>2017-11-18T14:44:47.000Z</published>
    <updated>2018-05-04T08:20:23.518Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/11/18/设计模式之单例模式/你是我的唯一.png"><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><footer><strong>艾迪生维斯理 《设计模式》</strong></footer></blockquote><a id="more"></a><blockquote><p>版权声明：本文为 <em>冬夏</em> 原创文章，可以随意转载，但请注明出处。</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在我们日常编写程序的时候，经常需要一种这样的对象。我们希望整个系统只有一个这样的对象，不论在什么时候和不论在哪里获取这个对象的时候，获得的都是同一个对象。</p><p>比如说系统的任务管理器，我们希望整个系统只有一个任务管理器，不论什么时候打开任务管理器，都可以看到当前系统的所有任务，而不是把任务分散在很多个任务管理器里。</p><p>又比如说打印机，当电脑连接上一台打印机的时候，我们会希望不管是在文档A里使用或者在文档B里使用的时候，都是同一台打印机，而且能够按顺序打印。</p><p>我们把这种类似的需求不断总结并归纳起来，就成了单例模式。</p><p>单例模式可以说是所有设计模式里面最简单的了，但是要灵活并且准确地使用它也不是那么容易的。</p><p>首先观察一下单例模式的 UML 图。</p><img src="/2017/11/18/设计模式之单例模式/singleton.png"><p>从 UML 图中我们可以观察到单例模式的几个特点</p><ol><li><p>私有的、静态的实例对象</p></li><li><p>私有的构造函数</p></li><li><p>公有的、静态的获取实例对象的方法</p></li></ol><p>那么，什么样的代码可以同时满足这几个特点呢？</p><h1 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h1><p>所谓的懒汉模式，就是一开始并不实例化对象，等到需要使用的时候才实例化。</p><pre><code>{% codeblock 懒汉模式 lang:java %}    public class Singleton {      private static Singleton instance = null;      private Singleton(){}      public static Singleton getInstance() {          if (instance == null)          {              instance = new Singleton();          }          return instance;      }    }    {% endcodeblock %}</code></pre><p>从上面的代码我们可以看到，当第一次获取 Singleton 实例的时候，instance 为空，将创建 Singleton 对象，并赋值给 instance 变量。以后的每次一获取都将获得第一次创建的 Singleton 对象，从而实现了唯一性。</p><h2 id="线程安全验证"><a href="#线程安全验证" class="headerlink" title="线程安全验证"></a>线程安全验证</h2><p>仔细想想这段代码，可能存在什么问题呢？</p><p>假设有这么一种情况， Singleton 对象还没有创建，这时候有很多个线程同时获取 Singleton 对象，这时候会发生什么呢？</p><p>用下面的代码可以验证</p><pre><code>{% codeblock 懒汉模式 线程安全验证 lang:java %}    public class Singleton {      private static int count = 0;      private static Singleton instance = null;      private Singleton(){          try {              Thread.sleep(10);          }catch (InterruptedException e){          }          System.out.println("Singleton 私有构造方法被调用 " + ++count + "次");      }      public static Singleton getInstance() {          if (instance == null)          {              instance = new Singleton();          }          return instance;      }    }    public class Test {      public static void main(String[] args){          Runnable runnable = new Runnable() {              @Override              public void run() {                  Singleton singleton = Singleton.getInstance();                  System.out.println("当前线程：" + Thread.currentThread().getName() +                          " Singleton: " + singleton.hashCode());              }          };          for (int i = 0; i < 10; i++){              new Thread(runnable).start();          }      }    }    {% endcodeblock %}</code></pre><p>从上面的代码可以看到，我们对懒汉模式做了一点小修正，在创建 Singleton 对象的时候让当前线程休眠了10ms，这主要是因为计算机运算速度太快了，不让当前线程休眠一下的话很难出现想要的结果。关于休眠我们可以把它想象成创建对象的过程中需要消耗一定的时间。</p><p>运算部分结果如下：</p><pre><code>{% codeblock 懒汉模式 线程安全验证结果 lang:java %}    Singleton 私有构造方法被调用 1次    当前线程：Thread-1 Singleton: 2044439889    Singleton 私有构造方法被调用 4次    Singleton 私有构造方法被调用 3次    Singleton 私有构造方法被调用 2次    当前线程：Thread-0 Singleton: 605315508    当前线程：Thread-2 Singleton: 2298428    当前线程：Thread-3 Singleton: 1005746524    当前线程：Thread-4 Singleton: 1005746524    当前线程：Thread-5 Singleton: 1005746524    当前线程：Thread-6 Singleton: 1005746524    当前线程：Thread-7 Singleton: 1005746524    当前线程：Thread-8 Singleton: 1005746524    当前线程：Thread-9 Singleton: 1005746524    {% endcodeblock %}</code></pre><p>从上面的结果可以看到，Singleton 的私有构造方法被调用了不止一次。对此的解释是，当第一次获取 Singleton 对象还没完成的时候，线程被系统挂起了，这时候有其他线程刚好也获取了 Singleton 对象，那么就会产生多个 Singleton 对象。</p><p>由此我们可以得出结论：懒汉模式是 <em>非线程安全</em> 的。</p><h1 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h1><p>为了解决懒汉模式非线程安全的缺点，就出现了改进的懒汉模式。其原理是当多个线程同时获取 Singleton 对象时，一次只让一个线程获取，其他线程都在等待，这样就解决了多线程下的对象获取问题。</p><pre><code>{% codeblock 同步方法 lang:java %}    public class Singleton {      private static Singleton instance = null;      private Singleton(){}      public static synchronized Singleton getInstance() {          if (instance == null)          {              instance = new Singleton();          }          return instance;      }    }    {% endcodeblock %}</code></pre><p>我们通过 <em>synchronized</em> 关键字让 getInstance()方法一次只能让一个线程调用，但是随着而来的又有另外一个问题。</p><p>那就是 <em>效率问题</em>，因为只有第一次获取 Singleton 对象时有可能发生线程安全问题，但是使用同步方法却让每次只让一个线程能访问getInstance()方法，而不管 Singleton 对象是不是已经被创建出来了。</p><p>那么有没有办法能同时解决线程安全和效率问题呢？</p><h1 id="双重校验"><a href="#双重校验" class="headerlink" title="双重校验"></a>双重校验</h1><p><em>双重校验</em> 方式就是为了解决懒汉模式的线程安全和效率问题而产生的。</p><pre><code>{% codeblock 双重校验 lang:java %}    public class Singleton {      private static Singleton instance = null;      private Singleton(){}      public static Singleton getInstance() {          if (instance == null){              synchronized (Singleton.class){                  if (instance == null){                      instance = new Singleton();                  }              }          }          return instance;      }    }    {% endcodeblock %}</code></pre><p>双重校验就是将前面两种懒汉模式结合起来。当第一次获取 Singleton 对象时， instance 为空， 这时候为了解决可能存在的线程安全问题，同步了 Singleton 这个类对象。也就是说，同一时刻只能有一个线程能够执行 synchronized 之后的代码。同时因为同步代码外层有一个条件语句，所以同步代码只有在第一次获取 Singleton 对象的时候执行到，这样就解决了效率问题。</p><p>但是这种方法还是有一个问题，那就是 <code>instance = new Singleton()</code> 这一行代码并不是原子性的</p><p>具体来说，JVM执行这一行代码时主要做了三件事</p><ol><li>给 instance 分配内存空间</li><li>调用 Singleton 的构造函数来初始化成员变量</li><li>将 instance 变量指向分配的内存空间（执行完这一步之后 instance 就不为 null 了）</li></ol><p>由于 JVM 的指令优化存在，上面的第二点和第三点并不能保证一定按顺序执行。也就是说执行顺序有可能为 1-2-3 或者 1-3-2。</p><p>假设是 1-3-2，那么如果执行到3的时候，线程被抢占了，有另外一个线程获取了单例对象（这时候 instance 不为 null，但是还没有初始化），那么自然就会出现错误。</p><p>为了解决这个问题，我们只要将 instance 变量声明成 volatile 就可以了。</p><p><code>private static volatile Singleton instance = null;</code></p><p>volatile 关键字主要有两个特性</p><ol><li>可见性：保证线程没有变量的本地副本，每次都去主内存获取最新版本</li><li>禁止指令重排序：生成内存屏障</li></ol><p>很明显，我们这里利用的是 volatile 的第二个特性。</p><p>特别注意的是只有在 Java 5 之后使用这种方式才是完全安全的，原因是 Java 5 之前的 Java 内存模型（Java Memory Model，JMM）存在缺陷，即使变量声明为 volatile 也不能完全避免重排序，这个问题在 Java 5 之后才修复。</p><h1 id="恶汉模式"><a href="#恶汉模式" class="headerlink" title="恶汉模式"></a>恶汉模式</h1><p>这时候我们可以换个思路，既然懒汉模式是因为需要的时候才创建对象，所以才让程序有机会可以产生多个对象。那如果我一开始就把对象创建好了，不就行了吗？这就出现了恶汉模式。</p><p>恶汉模式的意思是不管对象目前有没有使用，都会先创建出来。</p><pre><code>{% codeblock 恶汉模式 lang:java %}    public class Singleton {      private static final Singleton instance = new Singleton();      private Singleton(){}      public static Singleton getInstance() {          return instance;      }    }    {% endcodeblock %}</code></pre><p>从代码中可以看到，由于在 Singleton 类加载时就创建了 Singleton 对象，所以恶汉模式是 <em>线程安全</em> 的。</p><p>但是恶汉模式存在的问题就是不管目前对象有没有被使用，都被创建了出来，浪费了内存空间。</p><h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><p>静态方法的单例模式和恶汉模式的原理一样，都是利用了classloader，在类加载的时候就创建了 Singleton 对象。</p><pre><code>{% codeblock 静态方法 lang:java %}    public class Singleton {      private static Singleton instance = null;      static {          instance = new Singleton();      }      private Singleton(){}      public static Singleton getInstance() {          return instance;      }    }    {% endcodeblock %}</code></pre><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><p>静态内部类的方法和上面两种方法既有相似的地方，也有不同的地方。</p><pre><code>{% codeblock 静态内部类 lang:java %}    public class Singleton {      private static class SingletonHolder{          private static final Singleton INSTANCE = new Singleton();      }      private Singleton(){}      public static Singleton getInstance() {          return SingletonHolder.INSTANCE;      }    }    {% endcodeblock %}</code></pre><p>从代码种我们可以看到，静态内部类的方法和前两种方法一样，都是利用了classloader，在加载类的时候创建 Singleton 对象。</p><p>不同的地方在于加载的类不同。静态内部类方法在加载 Singleton 类的时候不会创建 Singleton 对象。而是在加载 SingletonHolder 类的时候才会。那么 SingletonHolder 类是什么时候加载的呢？</p><p>根据JVM（Java 虚拟机）的类加载规则，静态内部类只有在主动调用的时候才会加载。也就是说，在第一次调用 getInstance() 方法时才会加载 SingletonHolder 类，同时创建了 Singleton 对象。</p><p>也可以说，静态内部类的方法利用JVM解决了前两种方法占用内存的问题。</p><h2 id="防止单例受到攻击"><a href="#防止单例受到攻击" class="headerlink" title="防止单例受到攻击"></a>防止单例受到攻击</h2><p>到目前为止，我们所分析的所有单例模式都有一个前提，那就是调用者非常听话地使用了 Singleton.getInstance() 方法获取单例对象。但是在现实生活中是不是都是这样的呢？会不会有不怀好意的人使用其他方式破坏我们的单例模式呢？</p><p>我们先思考一下，获取一个对象有几种方式</p><ol><li>使用 new 关键字</li><li>通过反射调用</li><li>序列化</li></ol><p>我们前面的单例模式都是通过第一种方式获取对象的，那么如果采用其他两种方式，之前的单例模式还安全吗？答案是否定的。</p><h3 id="反射攻击"><a href="#反射攻击" class="headerlink" title="反射攻击"></a>反射攻击</h3><p>首先我们来看一下反射调用，以双重检验方式为例</p><pre><code>{% codeblock 反射攻击 lang:java %}    public class Singleton {      private static volatile Singleton instance = null;      private Singleton(){}      public static Singleton getInstance() {          if (instance == null){              synchronized (Singleton.class){                  if (instance == null){                      instance = new Singleton();                  }              }          }          return instance;      }    }    public class Test {        public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException,                InvocationTargetException, InstantiationException{            Singleton singleton1 = Singleton.getInstance();            Class<?> classType = Singleton.class;            Constructor<?> constructor = classType.getDeclaredConstructor(null);            constructor.setAccessible(true);            Singleton singleton2 = (Singleton) constructor.newInstance();            System.out.println(singleton1 == singleton2);  //false        }    }    {% endcodeblock %}</code></pre><p>输出结果是</p><pre><code>{% codeblock 反射攻击结果 lang:java %}    Singleton 私有构造方法被调用 1次    Singleton 私有构造方法被调用 2次    false    {% endcodeblock %}</code></pre><p>从结果可以看到，私有的构造函数被调用了两次，也就是说这样的单例模式并不安全。</p><p>为了防止单例模式被反射攻击，我们可以添加一个标志位，在新建对象时判断是否已经新建过对象了。</p><pre><code>{% codeblock 防止反射攻击 lang:java %}    public class Singleton {      private static boolean flag = false;      private static volatile Singleton instance = null;      private Singleton(){          if (!flag){              flag = true;          }else {              throw new RuntimeException("构造函数被调用多次");          }      }      public static Singleton getInstance() {          if (instance == null){              synchronized (Singleton.class){                  if (instance == null){                      instance = new Singleton();                  }              }          }          return instance;      }    }    {% endcodeblock %}</code></pre><p>当然这种方式也有一个缺点，那就是必须保证 Singleton.getInstance() 方法在反射之前调用，否则将不能正确获取单例对象。</p><p>而且,既然我们可以通过反射创建出对象，那么也可以通过反射修改标志位的值，这样一来，使用标志位的方法就不能完全防止反射攻击了。</p><h3 id="序列化攻击"><a href="#序列化攻击" class="headerlink" title="序列化攻击"></a>序列化攻击</h3><p>接下来我们看一下序列化如何破坏单例模式，以恶汉模式为例。</p><pre><code>{% codeblock 序列化攻击 lang:java %}    public class Singleton implements Serializable{      private static final Singleton instance = new Singleton();      private Singleton(){}      public static Singleton getInstance() {          return instance;      }    }    public class Test {      public static void main(String[] args) throws IOException,ClassNotFoundException{          Singleton singleton1 = Singleton.getInstance();          Singleton singleton2;          FileOutputStream fos = new FileOutputStream("SerSingleton.obj");          ObjectOutputStream oos = new ObjectOutputStream(fos);          oos.writeObject(singleton1);          oos.flush();          oos.close();          FileInputStream fis = new FileInputStream("SerSingleton.obj");          ObjectInputStream ois = new ObjectInputStream(fis);          singleton2 = (Singleton)ois.readObject();          System.out.println(singleton1==singleton2);      }    }    {% endcodeblock %}</code></pre><p>输出结果为 <code>false</code> 表明我们的单例收到了攻击，那么如何防止这种情况呢？</p><p>我们可以在被序列化的类中添加readResolve方法</p><pre><code>{% codeblock 防止序列化攻击 lang:java %}    public class Singleton implements Serializable{      private static final Singleton instance = new Singleton();      private Singleton(){}      public static Singleton getInstance() {          return instance;      }      private Object readResolve(){          return instance;      }    }    {% endcodeblock %}</code></pre><p>说了这么多，不知道大家有没有这样一种感慨 「 都说单例模式是最简单的一种模式，这么还这么复杂，以后还让不让人活了 」。</p><p>那么有没有一种又简单有能防止所有攻击的方法呢？</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举( enum )是 Java1.5 之后新加的特性。</p><p>大家一定很奇怪，为什么枚举可以实现单例呢？其实和 Java 的编译特性有关。因为枚举是 Java1.5 之后新加的，一般新加入的功能有一个很重要的问题需要解决，就是对以前代码的兼容性问题。而 Java 是通过 <em>语法糖</em> 的方式解决的。简单来说就是编写代码的时候可以使用新的关键字 <em>enum</em> 编写程序，但是 Java 编译器在编译成字节码的时候，还是会利用现有的技术编译成之前的 JVM 能够识别并正确运行的字节码，这就是语法糖技术。</p><p>我们先来看一下枚举编写的单例是什么样子的。</p><pre><code>{% codeblock 枚举 lang:java %}    public enum Singleton {      INSTANCE;      public static Singleton getInstance(){          return INSTANCE;      }      public void otherMethods(){          System.out.println("do something");      }    }    {% endcodeblock %}</code></pre><p>这段代码看起来很简单，我们定义了一个枚举类型 INSTANCE, 这就是我们需要的单例。但是为什么这样就能实现线程安全的单例呢？要解决这个疑问，我们必须把这段代码进行反编译，看看 java 编译器究竟是如何编译这段代码的。</p><p>我们使用 java 自带的反编译工具 javap 就可以将这段代码反编译</p><p>  <code>javap -c Singleton</code></p><p>反编译结果如下：</p><pre><code>{% codeblock 反编译 lang:java %}    public final class Singleton extends java.lang.Enum<singleton> {    public static final Singleton INSTANCE;    public static Singleton[] values();      Code:         0: getstatic     #1                  // Field $VALUES:[LSingleton;         3: invokevirtual #2                  // Method "[LSingleton;".clone:()Ljava/lang/Object;         6: checkcast     #3                  // class "[LSingleton;"         9: areturn    public static Singleton valueOf(java.lang.String);      Code:         0: ldc           #4                  // class Singleton         2: aload_0         3: invokestatic  #5                  // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;         6: checkcast     #4                  // class Singleton         9: areturn    public static Singleton getInstance();      Code:         0: getstatic     #7                  // Field INSTANCE:LSingleton;         3: areturn    public void otherMethods();      Code:         0: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #9                  // String do something         5: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: return    static {};      Code:         0: new           #4                  // class Singleton         3: dup         4: ldc           #11                 // String INSTANCE         6: iconst_0         7: invokespecial #12                 // Method "<init>":(Ljava/lang/String;I)V        10: putstatic     #7                  // Field INSTANCE:LSingleton;        13: iconst_1        14: anewarray     #4                  // class Singleton        17: dup        18: iconst_0        19: getstatic     #7                  // Field INSTANCE:LSingleton;        22: aastore        23: putstatic     #1                  // Field $VALUES:[LSingleton;        26: return    }    {% endcodeblock %}</init></singleton></code></pre><p>  可能这段代码对于刚刚接触 java 的人来说一时可能看不懂，但是我们只要关注到一下几点就好了。</p><ol><li><code>public final class Singleton extends java.lang.Enum&lt;Singleton&gt;</code> 这说明枚举类型实际上被 java 编译器通过语法糖转换成了不可变类，继承自 Enum<singleton> 类。</singleton></li><li><code>public static final Singleton INSTANCE</code>,说明我们定义的枚举值 INSTANCE 实际上被 java 编译器转换成了不可变对象，只可以初始化一次。</li><li>关注到 INSTANCE 实际上是在 static {} 这段代码里初始化的。也就是说， INSTANCE 是在 Singleton 类加载的时候初始化的，所以一旦 Singleton 类加载了，INSTANCE 也就初始化了，不能再改变了，这就实现了单例模式。</li></ol><p>然后如果我们尝试使用序列化或者反射的方式去攻击枚举单例，会发现都不能成功，这是由于 JVM 实现枚举的机制决定的。</p><p>最后，引用一下 《Effective Java》一书中的话。</p><blockquote><p>单元素的枚举类型已经成为实现Singleton的最佳方法。</p><footer><strong>《Effective Java》</strong></footer></blockquote>  ]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/11/18/设计模式之单例模式/你是我的唯一.png&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;艾迪生维斯理 《设计模式》&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongxiawu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="https://dongxiawu.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="线程安全" scheme="https://dongxiawu.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
